<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2FBlog%2F2019%2F04%2F04%2Fhoc-context%2F</url>
    <content type="text"><![CDATA[jr_gd_fe工单系统]]></content>
  </entry>
  <entry>
    <title><![CDATA[BOM（Browser Object Model）浏览器对象模型]]></title>
    <url>%2FBlog%2F2019%2F03%2F21%2FBOM%2F</url>
    <content type="text"><![CDATA[1.定义1.1 BOM是什么？ BOM（Browser Object Model）即浏览器对象模型。 BOM提供了独立于内容 而与浏览器窗口进行交互的对象,其核心对象是window； BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性； BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分。W3C 为了把浏览器中JavaScript 最基本的部分标准化，已经将BOM的主要方面纳入了HTML5 的规范中。 1.2 BOM包含什么？ 2.window对象2.1 全局作用域BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象有双重角色，它既是通过javascript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。 因此，所有全局作用域中声明的变量、函数都会变成window对象的属性和方法。1234567891011121314 var age=26;//这里定义的全局变量和全局函数被自动归在了window对象名下function sayAge()&#123; console.log(this.age);&#125;console.log(window.age);//26sayAge();//26 相当于window.sayAge()window.sayAge();//26 //全局变量和在window对象上直接定义属性的唯一区别：全局变量不能够通过delete操作符删除，而直接在window对象上定义的属性可以window.color=&apos;red&apos;;delete window.age;delete window.color;console.log(window.age);//26console.log(window.color);//undefined See the Pen ErrdKK by vivizhou0596 (@vivizhou0596) on CodePen. 1234567/*还要注意：尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未经声明的变量是否存在 *///这会抛出错误，因为oldValue未定义var newValue=oldValue;//这不会抛出错误，因为是一次属性查询var newValue=window.oldValue; 2.2 窗口关系及框架如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。在frames集合中，可以通过数值索引(从0开始，从左到右，从上到下)或者框架名称来访问相应的window对象。每个window对象都有一个name属性，其中包含着框架的名称。 可以通过window.frames[0]或者window.frames[“topFrame”]来引用上方的框架。不过，最好使用top，而不是window来引用这些框架。因为，top对象始终指向最高(最外)层的框架，也就是浏览器窗口。使用它可以确保在一个框架中正确地访问另一个框架。因为对于一个在框架中编写的任何代码来说，其中的window对象指向的都是那个框架的特定实例，而不是最高层的框架。 与top相对的另一个window对象是parent。parent对象始终指向当前框架的直接上层框架。 与框架有关的最后一个对象是self，它始终指向window。self和window对象可以互换使用。 在使用框架的情况下，浏览器中会存在多个Global对象。在每个框架中定义的全局变量会自动成为框架中window对象的属性。由于每个window对象都包含原生类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应，但并不相等。 ① 如果文档包含框架（frame 或iframe标签），浏览器会为HTML文档创建一个window对象，并为每个框架创建一个额外的window对象。 ② window.frames 返回窗口中所有命名的框架 ③parent是父窗口（如果窗口是顶级窗口，那么parent==self==top）； top是最顶级父窗口（有的窗口中套了好几层frameset或者iframe）； self是当前窗口（等价window）； opener是用open方法打开当前窗口的那个窗口； 2.3窗口位置与大小2.3.1窗口位置窗口位置：窗口相对于屏幕左边和上边的位置screenLeft和screenTop属性：IE、Safari、Opera、ChromescreenX和screenY属性：Firefox、Safari、Chrome 在IE、Opera中，screenLeft和screenTop中保存 的是从屏幕左边和上边到由window对象表示的页面可见区域的距离在Chrome、Firefox和Safari中，screenY或screenTop中保存的是整个浏览器窗口相对于屏幕的坐标值，即在窗口的y轴坐标为0时返回0。 123var leftPos = (typeof window.screenLeft === &apos;number&apos;) ? window.screenLeft : window.screenX;var rightPos = (typeof window.screenTop === &apos;number&apos;) ? window.screenTop : window.screenY; 2.3.1窗口大小跨浏览器确定一个窗口的大小不是一件简单的事。IE9+、Firefox、Safari、Opera 和Chrome 均为此提供了4 个属性：innerWidth、innerHeight、outerWidth 和outerHeight。红宝书《JavaScript高级程序设计》上对这几个属性的描述如下： 1在IE9+、 Safari 和 Firefox、Opera中， outerWidth 和outerHeight 返回浏览器窗口本身的尺寸，而 innerWidth 和 innerHeight则表示该容器中页面视图区的大小(减去边框宽度)。在 Chrome中相应宽高返回相同的值，即视 口( viewport)大小而非浏览器窗口大小。 随手在windows上的Chrome上测试了一下，发现在并不如书中所述，并且在窗口处于最大化和最小化时表现也不一致，因此这些属性对于不同系统不同版本的浏览器表现可能都不一致，不能作为精确值使用。12345678var pageWidth=window.innerWidth, pageHeight=window.innerHeight, windowWdith=window.outerWidth, windowHeight=window.outerHeight; document.write(&quot;innerWidth=&quot;+pageWidth+&quot;&amp;emsp;&amp;emsp;&quot;); document.write(&quot;innerHeight=&quot;+pageHeight+&quot;&lt;br /&gt;&quot;); document.write(&quot;outerWidth=&quot;+windowWdith+&quot;&amp;emsp;&amp;emsp;&quot;); document.write(&quot;outerHeight=&quot;+windowHeight); 2.4超时调用和间歇调用(定时器)javascript是单线程语言，但允许通过设置超时值和间歇值来设定代码在特定时刻执行 超时调用（执行一次）：是在指定的时间过后执行代码 间歇调用（重复执行）：每隔指定的时间就执行一次代码 超时调用：需要使用window对象的setTimeout()方法，接收两个参数：要执行的代码和以毫秒表示的时间。 第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定执行。因为，javascript是一个单线程的解释器，因此一定时间内只能执行一段代码。第二个参数表示再过多长时间把当前任务添加到队列中。如果队列是空的，则代码会立刻执行，否则就要等待前面的代码执行完了以后再执行。 调用setTimeout()后，该方法会返回一个数值ID,表示超时调用。要取消未执行的超时调用计划，可以调用clearTimeout()方法并将相应的超时调用ID作为参数传递给它即可。 间歇调用：使用setInterval()方法 与超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直到间歇调用被取消或者页面被卸载。它接收的参数与setTimeout()方法一样 demo1123456 //设置超时调用var timeoutId = setTimeout(function() &#123; alert(&quot;Hello world!&quot;);&#125;, 1000);//取消超时调用clearTimeout(timeoutId); demo21234567891011var num = 0;var max = 10;var intervalId = null;function incrementNumber() &#123; console.log(num++); if (num == max) &#123; clearInterval(intervalId); alert(&quot;Done&quot;); &#125;&#125;intervalId = setInterval(incrementNumber, 500); demo31234567891011121314/* 使用超时调用来实现 */ var num = 0; var max = 100; function incrementNumber() &#123; num++; if (num &lt; max) &#123; setTimeout(incrementNumber, 500); &#125; else &#123; alert(&quot;Done&quot;); &#125; &#125; setTimeout(incrementNumber, 500); 在使用超时调用时，没有必要跟踪超时调用ID，因为每次执行代码之后，如果不再设置另一次超时调用，调用就会自动停止。一般认为，使用超时调用来模拟间歇调用是一种最佳模式。间歇调用一般较少使用，因为后一个间歇调用可能会在前一个间歇调用结束之前启动 2.5系统对话框alert()、confirm()和prompt()浏览器通过alert()、confirm()和prompt()方法可以调用系统对话框向用户显示消息。系统对话框与在浏览器中显示的网页没有关系，也不包含HTML。它们的外观由操作系统及（或）浏览器设置决定，而不是由CSS 决定。此外，通过这几个方法打开的对话框都是同步和模态的。也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。1alert(&quot;Hello world!&quot;); confirm()方法用于显示一个带有指定消息和确认及取消按钮的对话框。判断用户点击了OK还是Cancel，可以检查confirm()方法返回的布尔值：true表示单击了OK，false表示单击了Cancel或单击了右上角的X按钮。 12345if (confirm(&quot;Are you sure?&quot;)) &#123; alert(&quot;I&apos;m so glad you&apos;re sure! &quot;);&#125; else &#123; alert(&quot;I&apos;m sorry to hear you&apos;re not sure. &quot;);&#125; prompt()方法用来生成一个”提示”框，用于提示用户输入一些文本。提示框除了显示OK和Cancel按钮之外 ，还会显示一个文本输入域，用来输入文本内容。该方法接收两个参数：要显示给用户的文本提示和文本输入域的默认值(可以是一个空字符串) 1234var result = prompt(&quot;What is your name? &quot;, &quot;&quot;);if (result !== null) &#123; alert(&quot;Welcome, &quot; + result);&#125; 3.Location对象location对象是一个很特殊的对象，因为它既是window对象的属性，也是document对象的属性；换句话说，window.location和document.location引用的是同一个对象。location对象的用处不只表现在它保存着当前文档的信息，还表现在它将URL解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。下标列出了location对象的所有属性（省略了每个属性前面的location前缀）： 属性名 例子 说明 hash “#contents” 返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串 host “www.wrox.com:80&quot; 返回服务器名称和端口号（如果有） hostname “www.wrox.com&quot; 返回不带端口号的服务器名称 href “http:/www.wrox.com&quot; 返回当前加载页面的完整URL。而location对象的toString()方法也返回这个值 pathname “/WileyCDA/“ 返回URL中的目录和（或）文件名 port “8080” 返回URL中指定的端口号。如果URL中不包含端口号，则这个属性返回空字符串 protocol “http:” 返回页面使用的协议。通常是http:或https: search “?q=javascript” 返回URL的查询字符串。这个字符串以问号开头 查询字符串参数虽然上面的属性可以访问到location对象的大多数信息，但是其中访问URL包含的查询字符串的属性并不方便。尽管location.search返回从问号到URL末尾的所有内容，但是却没有办法逐个访问其中的每个查询字符串参数。因此可以创建一个函数，用以解析查询字符串，然后返回包含所以参数的一个对像。 123456789101112131415161718192021222324 function getQueryStringArgs()&#123; //取得查询字符串并去掉开头的问号 var qs = (location.search.length &gt; 0 ? location.search.substring(1) : &quot;&quot;), //保存数据的对象 args = &#123;&#125;, //取得每一项 items = qs.length ? qs.split(&quot;&amp;&quot;) : [], item = null, name = null, value = null, //在for 循环中使用 i = 0, len = items.length; //逐个将每一项添加到args 对象中 for (i=0; i &lt; len; i++)&#123; item = items[i].split(&quot;=&quot;); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; return args;&#125; 3.1位置操作使用location对象可以通过很多方式来改变浏览器的位置。最常用的方式就是使用assign()方法并为它传递一个参数URL：1location.assign(&apos;http://www.wrox.com&apos;); 这样就可以打开新URL，并在浏览器的历史记录中生成一条记录。如果将location.href和window.location设置为一个URL值。也会以该值调用assign()方法。下面的两行代码的效果是一样的：12 window.location = &apos;http://www.wrox.com&apos;;location.href = &apos;http://www.wrox.com&apos;; 最常用的是设置location.href属性。修改location对象的其他属性也可以改变当前加载的页面：123456789101112//假设初始值URL为：http://www.wrox.com/WileyCDA//将URL修改为：http://www.wrox.com/WileyCDA/#sectionlocation.hash = &apos;#section&apos;;//将URL修改为：http://www.wrox.com/WileyCDA/?q=javascriptlocation.search = &apos;?q=javascript&apos;;//将URL修改为：http://www.wrox.com/WileyCDA/location.hostname = &apos;www.wrox.com&apos;;//将URL修改为：http://www.wrox.com/mydirlocation.pathname = &apos;mydir&apos;;//将URL修改为：http://www.wrox.com:8080/WileyCDA/location.port = 8080;// 每次修改location的属性（hash除外）都会以新URL重新加载 当通过上述任何一种方式修改URL后，浏览器的历史记录中就会生成一条新记录。要禁用这种行为可以使用replace()方法，这个方法只接收一个参数，既要导航到的URL，结果虽然导致浏览器位置变化，但不在历史记录中生成新记录。在调用replace()方法后，用户不能回到前一个页面，此时后退按钮将处于禁用状态：1location.replace(&apos;www.wrox.com&apos;); 与为重有关的最后一个方法是reload()，作用是重新加载当前显示的页面。如果调研那个reload()不传递任何参数，页面就以最有效的方式重载，也就是从浏览器缓存中冲洗加载；如果想强制从服务器重新加载，则需要：12location.reload(); //从页面加载location.reload(true); //从服务器加载 位于reload()方法后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素，因此，最好将reload()放在代码的最后一行。 4.Navigator对象最早由NetscapeNavigator2.0引入的navigator对象，现在已经成为识别客户端浏览器的事实标准。虽然其他浏览器也通过其他方式提供了相同或相似的信息（例如，IE 中的window.clientInformation和Opera 中的window.opera），但navigator 对象却是所有支持JavaScript 的浏览器所共有的。与其他BOM 对象的情况一样，每个浏览器中的navigator 对象也都有一套自己的属性。 Navigator属性虽然多，但是感觉都不太实用，列出几个在项目中实际用到的东西。 *1、navigator.appCodeName（不准确）：属性是一个只读字符串，声明了浏览器的代码名。 在所有以 Netscape 代码为基础的浏览器中，它的值是 &quot;Mozilla&quot;。为了兼容起见，在 Microsoft 的浏览器中，它的值也是 &quot;Mozilla&quot;，同时在safari在浏览器的console里运行navigator.appCodeName得出的结果还是&quot;Mozilla&quot;，所以这个看起来并不实用，因为IE、chrome、safari返回的都是“Mozilla”。 *2、navigator.appName（不准确）：返回所使用浏览器的名称。 由于兼容性问题，HTML5 规范允许该属性返回 &quot;Netscape&quot;。该属性并不一定能返回正确的浏览器名称。在基于 Gecko 的浏览器 （例如 Firefox）和基于 WebKit 的浏览器（例如 Chrome 和 Safari）中，返回的浏览器名称都是 &quot;Netscape&quot;。 *3、navigator.appVersion（已废弃）：属性可返回浏览器的平台和版本信息。 该属性是一个只读的字符串。该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。 *4、navigator.platform：属性是一个只读的字符串，声明了运行浏览器的操作系统和（或）硬件平台。 可能的值有: &quot;Win32&quot;, &quot;Linux i686&quot;, &quot;MacPPC&quot;, &quot;MacIntel&quot;等。 *5、navigator.userAgent（用的最多，也可以说相对更准确）：属性是一个只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值。 由于是各家浏览器厂商都想要自己的浏览器被其他的兼容，所以都会或多或少的加上一些其他的信息在里面。 5.History对象history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。 注意:从窗口被打开的那一刻开始记录，每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。 语法： window.history.[属性|方法]注意：window可以省略。 History 对象属性 属性 描述 length 浏览器历史列表中的URL数量 History 对象方法 方法 描述 back() 加载 history 列表中的前一个 URL。 forward() 加载 history 列表中的下一个 URL。 go() 根据当前所处的页面，加载 history 列表中的某个具体的页面。 HTML5引入了histtory.pushState()和history.replaceState()这两个方法，他们允许添加和修改history实体。同时，这些方法会和window.onpostate事件一起工作。pushState方法pushState()有三个参数:state对象，标题(现在是被忽略，未作处理)，URL(可选)。具体细节： state对象 –state对象是一个JavaScript对象，它关系到由pushState()方法创建出来的新的history实体。用以存储关于你所要插入到历史 记录的条目的相关信息。State对象可以是任何Json字符串。因为firefox会使用用户的硬盘来存取state对象，这个对象的最大存储空间为640k。如果大于这个数 值，则pushState()方法会抛出一个异常。如果确实需要更多的空间来存储，请使用本地存储。 title—firefox现在回忽略这个参数，虽然它可能将来会被使用上。而现在最安全的使用方式是传一个空字符串，以防止将来的修改。或者可以传一个简短的标题来表示state URL—这个参数用来传递新的history实体的URL，注意浏览器将不会在调用pushState()方法后加载这个URL。但也许会过一会尝试加载这个URL。比如在用户重启了浏览器后，新的url可以不是绝对路径。如果是相对路径，那么它会相对于现有的url。新的url必须和现有的url同域，否则pushState()将抛出异常。这个参数是选填的，如果为空，则会被置为document当前的url。 某种意义上来说，调用pushState()方法很像设置了window.location = “#foo”,这两者都会创建和激活另一个关联到当前document的history实体，但pushState()另外有一些优点： l 如果不需要，你可以不修改url。对比而言，设置window.location = “#foo”;仅产生新的history实体，如果你当前的hash不是#foo 2 你可以将任意的数据与你的新history实体关联。使用基于hash的方法，需要将所有相关的数据编码为一个短字符串。 注意，pushState()方法不会使hashchange时间发生，即使是新旧url只是hash不同。 replaceState()方法history.replaceState() 用起来很像pushState()，除了replaceState()是用来修改当前的history实体而不是创建一个新的。这个方法有时会很有用，当 你需要对某些用户行为作反应而更新一个state对象或者当前history实体时，可以使用它来更新state对象或者当前history实体的url。 popstate事件当history实体被改变时，popstate事件将会发生。如果history实体是有pushState和replaceState方法产生的，popstate事件的state属性会包含一份来自history实体的state对象的拷贝 详见window.onpopstate 读取当前的state当页面加载时，它可能会有一个非空的state对象。这可能发生在当页面设置一个state对象(使用pushState或者replaceState)之后用户重启了浏览器。当页面重新加载，页面将收到onload事件，但不会有popstate事件。然而，如果你读取history.state属性，将在popstate事件发生后得到这个state对象var currentState = history.state; 6.小结浏览器对象模型（BOM）以window 对象为依托，表示浏览器窗口以及页面可见区域。同时，window对象还是ECMAScript 中的Global 对象，因而所有全局变量和函数都是它的属性，且所有原生的构造函数及其他函数也都存在于它的命名空间下。本章讨论了下列BOM的组成部分。 在使用框架时，每个框架都有自己的window 对象以及所有原生构造函数及其他函数的副本。每个框架都保存在frames 集合中，可以通过位置或通过名称来访问。 有一些窗口指针，可以用来引用其他框架，包括父框架。 top 对象始终指向最外围的框架，也就是整个浏览器窗口。 parent 对象表示包含当前框架的框架，而self 对象则回指window。 使用location 对象可以通过编程方式来访问浏览器的导航系统。设置相应的属性，可以逐段或整体性地修改浏览器的URL。 调用replace()方法可以导航到一个新URL，同时该URL 会替换浏览器历史记录中当前显示的页面。 navigator 对象提供了与浏览器有关的信息。到底提供哪些信息，很大程度上取决于用户的浏览器；不过，也有一些公共的属性（如userAgent）存在于所有浏览器中。BOM 中还有两个对象：screen 和history，但它们的功能有限。screen 对象中保存着与客户端显示器有关的信息，这些信息一般只用于站点分析。history 对象为访问浏览器的历史记录开了一个小缝隙，开发人员可以据此判断历史记录的数量，也可以在历史记录中向后或向前导航到任意页面。 参考链接： react-router原理]]></content>
      <categories>
        <category>js 基础</category>
      </categories>
      <tags>
        <tag>js基础, -BOM, -浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位操作符]]></title>
    <url>%2FBlog%2F2019%2F03%2F14%2Fbitwise-operators%2F</url>
    <content type="text"><![CDATA[原码, 反码, 补码 原码（True Form）使用高位作为符号位。最高位为0时表示正数，最高位为1时则表示为负数。其余位使用此数字数值本身二进制的绝对值表示。 原码的设计不便于加减运算。 反码（Ones’ Complement）使用高位作为符号位。最高位为0时表示正数，最高位为1时则表示为负数。正数的反码还是正数本身，负数的补码就是其绝对值相同的正数取反的结果。即在原码的基础上，符号位不变，其他位取反的结果。 反码的设计依然不便于加减运算。 补码（Twos’ Complement）使用高位作为符号位。最高位为0时表示正数，最高位为1时则表示为负数。正数的补码就是正数本身，负数的补码就是其原码取反加一的结果。补码设计的目的，就是讲将原二进制数，分一半做负数，而取反加一的规律则是在此设计的基础上归纳得来的。所以，使用“取反加一”来定义补码，是与设计相悖的。 补码的设计，方便了二进制的加减运算。 转换 正数：原码，反码，补码都一样。 负数： 原码和反码的相互转换：符号位不变，数值位按位取反 原码和补码的相互转换：符号位不变，数值位按位取反,末位再加1 已知补码，求原码的负数的补码：符号位和数值位都取反，末位再加1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 8的八位原码，反码，补码// 0000 1000// -8的八位原码，反码，补码// 原：1000 1000// 反：1111 0111// 补：1111 1000// 实现一个二进制类：function Binary(num, opt)&#123; this.num = num; this.opt = opt; this.binary_str = num.toString(2);&#125;Binary.prototype.getTrues= function(bitwise) &#123; var trues = &apos;&apos;; if (this.num &gt;= 0) &#123; trues = (Array(bitwise).join(&quot;0&quot;) + this.binary_str).slice(-bitwise); &#125; if(this.num &lt; 0)&#123; trues = &apos;1&apos; + (Array(bitwise).join(&quot;0&quot;) + this.binary_str).slice(-(bitwise - 1)).replace(&apos;-&apos;,0); &#125; return trues;&#125;Binary.prototype.getOnes =function(bitwise) &#123; var ones = &apos;&apos;; if (this.num &gt;= 0) &#123; ones = (Array(bitwise).join(&quot;0&quot;) + this.binary_str).slice(-bitwise); &#125; if(this.num &lt;= 0)&#123; ones = &apos;1&apos; + (Array(bitwise).join(&quot;0&quot;) + this.binary_str).slice(-(bitwise - 1)).replace(&apos;-&apos;,0).split(&apos;&apos;).map(bit=&gt;bit==&apos;0&apos;?&apos;1&apos;:&apos;0&apos;).join(&apos;&apos;); &#125; return ones;&#125;Binary.prototype.getTwos =function(bitwise) &#123; var twos = &apos;&apos;, parse_ones_add_1 = parseInt(this.getOnes(bitwise), 2) + 1; if (this.num &gt;= 0) &#123; twos = (Array(bitwise).join(&quot;0&quot;) + this.binary_str).slice(-bitwise); &#125; if(this.num &lt;= 0)&#123; twos = &apos;1&apos;+(Array(bitwise).join(&quot;0&quot;) + parse_ones_add_1.toString(2)).slice(-(bitwise - 1)).replace(&apos;-&apos;,0); &#125; return twos;&#125;Binary.prototype.toString = function(bitwise = 32) &#123; var str = ` ====== 真值: $&#123;this.binary_str&#125;; 原码: $&#123;this.getTrues(bitwise)&#125;; 反码：$&#123;this.getOnes(bitwise)&#125;; 补码：$&#123;this.getTwos(bitwise)&#125;; ====== `; return str;&#125;Binary.prototype.valueOf = function() &#123; return parseInt(this.num, 10);&#125;Binary.format = function(str = &apos;&apos;, length = 4, replaceStr = &apos; &apos;) &#123; var reg = new RegExp(`(\\d)(?=(\\d&#123;$&#123;length&#125;&#125;)+(?!\\d))`, &apos;gi&apos;); return str.replace(reg, `$&amp;$&#123;replaceStr&#125;`);&#125;var a = new Binary(+new Binary(-11123));var format = Binary.format;console.log(a.toString(32));console.log(format(a.getTrues(32)));console.log(format(a.getOnes(32)));console.log(format(a.getTwos(32))); 在线实例：实现二进制类 位操作符概述按位操作符（Bitwise operators） 将其操作数（operands）当作32位的比特序列（由0和1组成），而不是十进制、十六进制或八进制数值。例如，十进制数9，用二进制表示则为1001。按位操作符操作数字的二进制形式，但是返回值依然是标准的JavaScript数值。 运算符 用法 描述 按位与（ AND） a &amp; b 对于每一个比特位，只有两个操作数相应的比特位都是1时，结果才为1，否则为0。 按位或（OR） a &#124; b 对于每一个比特位，当两个操作数相应的比特位至少有一个1时，结果为1，否则为0。 按位异或（XOR） a ^ b 对于每一个比特位，当两个操作数相应的比特位有且只有一个1时，结果为1，否则为0。 按位非（NOT） ~a 反转操作数的比特位，即0变成1，1变成0。 左移（Left shift） a &lt;&lt; b 将 a 的二进制形式向左移 b (&lt; 32) 比特位，右边用0填充。 有符号右移 a &gt;&gt; b 将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位。 无符号右移 a &gt;&gt;&gt; b 将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位，并使用 0 在左侧填充。 有符号32位整数所有的按位操作符的操作数都会被转成补码（two’s complement）形式的有符号32位整数。补码形式是指一个数的负对应值（negative counterpart）（如 5和-5）为数值的所有比特位反转后，再加1。反转比特位即该数值进行’非‘位运算，也即该数值的反码。 按位逻辑操作符从概念上讲，按位逻辑操作符按遵守下面规则： 操作数被转换成32位整数，用比特序列（0和1组成）表示。超过32位的数字会被丢弃。例如, 以下具有32位以上的整数将转换为32位整数。 第一个操作数的每个比特位与第二个操作数的相应比特位匹配：第一位对应第一位，第二位对应第二位，以此类推。 位运算符应用到每对比特位，结果是新的比特值。 123456789101112131415161718192021222324252627function logOperate(a, b, op) &#123; var ba = new Binary(a), bb = new Binary(b), format = Binary.format, opList = &#123; &apos;&amp;&apos;: (a, b) =&gt; a &amp; b, &apos;|&apos;: (a, b) =&gt; a | b, &apos;^&apos;: (a, b) =&gt; a ^ b, &apos;~&apos;: a =&gt; ~a, &apos;&lt;&lt;&apos;: (a, b) =&gt; a &lt;&lt; b, &apos;&gt;&gt;&apos;: (a, b) =&gt; a &gt;&gt; b, &apos;&gt;&gt;&gt;&apos;: (a, b) =&gt; a &gt;&gt; b, &#125;, bop = new Binary(opList[op](a, b));// console.log(format(ba.getTrues(32)));// console.log(format(bb.getTrues(32)));// console.log(format(bop.getTrues(32)));// console.log(format(ba.getOnes(32)));// console.log(format(bb.getOnes(32)));// console.log(format(bop.getOnes(32))); console.log(format(ba.getTwos(32))); console.log(format(bb.getTwos(32))); console.log(format(bop.getTwos(32))); &#125; &amp; (按位与)对每对比特位执行与（AND）操作。只有 a 和 b 都是 1 时，a AND b 才是 1。与操作的真值表如下: a b a&amp;b 0 0 0 0 1 0 1 0 0 1 1 1 将任一数值 x 与 0 执行按位与操作，其结果都为 0。将任一数值 x 与 -1 执行按位与操作，其结果都为 x。 123456789logOperate(2, 3, &apos;&amp;&apos;);// 0000 0000 0000 0000 0000 0000 0000 0010// 0000 0000 0000 0000 0000 0000 0000 0011// 0000 0000 0000 0000 0000 0000 0000 0010logOperate(-2, -3, &apos;&amp;&apos;);// 1111 1111 1111 1111 1111 1111 1111 1110// 1111 1111 1111 1111 1111 1111 1111 1101// 1111 1111 1111 1111 1111 1111 1111 1100 | (按位或)对每一对比特位执行或（OR）操作。如果 a 或 b 为 1，则 a OR b 结果为 1。或操作的真值表： a b a &#124; b 0 0 0 0 1 1 1 0 1 1 1 1 将任一数值 x 与 0 进行按位或操作，其结果都是 x。将任一数值 x 与 -1 进行按位或操作，其结果都为 -1。 123456789logOperate(2, 3, &apos;|&apos;);// 0000 0000 0000 0000 0000 0000 0000 0010// 0000 0000 0000 0000 0000 0000 0000 0011// 0000 0000 0000 0000 0000 0000 0000 0011logOperate(-2, -3, &apos;|&apos;);// 1111 1111 1111 1111 1111 1111 1111 1110// 1111 1111 1111 1111 1111 1111 1111 1101// 1111 1111 1111 1111 1111 1111 1111 1111 123456789101112131415161718192021222324251 | 0 ; // 11.1 | 0 ; // 1&apos;asfdasfda&apos; | 0 ; // 00 | 0 ; // 0(-1) | 0 ; // -1(-1.5646) | 0 ; // -1[] | 0 ; // 0(&#123;&#125;) | 0 ; // 0&quot;123456&quot; | 0 ; // 1234561.23E2 | 0; // 1231.23E12 | 0; // 1639353344-1.23E2 | 0; // -123-1.23E12 | 0; // -1639353344 ^ (按位异或)对每一对比特位执行异或（XOR）操作。当 a 和 b 不相同时，a XOR b 的结果为 1。异或操作真值表： a b a ^ b 0 0 0 0 1 1 1 0 1 1 1 0 123456789logOperate(2, 3, &apos;^&apos;);// 0000 0000 0000 0000 0000 0000 0000 0010// 0000 0000 0000 0000 0000 0000 0000 0011// 0000 0000 0000 0000 0000 0000 0000 0001logOperate(-2, -3, &apos;^&apos;);// 1111 1111 1111 1111 1111 1111 1111 1110// 1111 1111 1111 1111 1111 1111 1111 1101// 0000 0000 0000 0000 0000 0000 0000 0011 将任一数值 x 与 0 进行异或操作，其结果为 x。将任一数值 x 与 -1 进行异或操作，其结果为 ~x。 ~ (按位非)对每一个比特位执行非（NOT）操作。NOT a 结果为 a 的反转（即反码）。非操作的真值表： a ~a 0 1 1 1 对任一数值 x 进行按位非操作的结果为 -(x + 1)。例如，~5 结果为 -6。 123456789101112// 判断字符串是否存在：// eg: var str = &apos;heaven is a place nearby!&apos;;var search = &apos;a&apos;;// str.indexOf(search) &gt;= 0// -str.indexOf(search) &lt;= 0// ~str.indexOf(search)logOperate(2, 0, &apos;~&apos;);// 0000 0000 0000 0000 0000 0000 0000 0010// 1111 1111 1111 1111 1111 1111 1111 1101 按位移动操作符按位移动操作符有两个操作数：第一个是要被移动的数字，而第二个是要移动的长度。移动的方向根据操作符的不同而不同。 按位移动会先将操作数转换为大端字节序顺序(big-endian order)的32位整数,并返回与左操作数相同类型的结果。右操作数应小于 32位，否则只有最低 5 个字节会被使用。 123456注：Big-Endian:高位字节排放在内存的低地址端，低位字节排放在内存的高地址端，又称为&quot;高位编址&quot;。Big-Endian是最直观的字节序：①把内存地址从左到右按照由低到高的顺序写出；②把值按照通常的高位到低位的顺序写出；③两者对照，一个字节一个字节的填充进去。 &lt;&lt; (左移)该操作符会将第一个操作数向左移动指定的位数。向左被移出的位被丢弃，右侧用 0 补充。 在数字 x 上左移 y 比特得到 x * 2y. 1234567logOperate(2, 3, &apos;~&apos;); // 16// 0000 0000 0000 0000 0000 0000 0000 0010// 0000 0000 0000 0000 0000 0000 0001 0000logOperate(-2, 3, &apos;~&apos;); // -16// 1111 1111 1111 1111 1111 1111 1111 1110// 1111 1111 1111 1111 1111 1111 1111 0000 &gt;&gt; (有符号右移)该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“符号传播”。 1234567logOperate(8, 3, &apos;&gt;&gt;&apos;);// 0000 0000 0000 0000 0000 0000 0000 1000// 0000 0000 0000 0000 0000 0000 0000 0001logOperate(-5, 4, &apos;&gt;&gt;&apos;);// 1111 1111 1111 1111 1111 1111 1111 1011// 1111 1111 1111 1111 1111 1111 1111 1111 &gt;&gt;&gt; (无符号右移)该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（译注：即便右移 0 个比特，结果也是非负的。） 对于非负数，有符号右移和无符号右移总是返回相同的结果。 1234567logOperate(8, 3, &apos;&gt;&gt;&gt;&apos;);// 0000 0000 0000 0000 0000 0000 0000 1000// 0000 0000 0000 0000 0000 0000 0000 0001logOperate(-8, 3, &apos;&gt;&gt;&gt;&apos;);// 1111 1111 1111 1111 1111 1111 1111 1000// 1111 1111 1111 1111 1111 1111 1111 1111 位操作符代码实例 掩码位运算经常被用来创建、处理以及读取标志位序列——一种类似二进制的变量。虽然可以使用变量代替标志位序列，但是这样可以节省内存（1/32）。 掩码 (bitmask) 是一个通过与/或来读取标志位的位序列。典型的定义每个标志位的原语掩码如下，例如，有四个标志位：A,B,C,D 1234var FLAG_A = 1; // 0001var FLAG_B = 2; // 0010var FLAG_C = 4; // 0100var FLAG_D = 8; // 1000 新的掩码可以在以上掩码上使用逻辑运算创建。例如，掩码 1011 可以通过 FLAG_A、FLAG_B 和 FLAG_D 逻辑或得到： 1var mask = FLAG_A | FLAG_B | FLAG_D; // 0001 | 0010 | 1000 =&gt; 1011 某个特定的位可以通过与掩码做逻辑与运算得到，通过与掩码的与运算可以去掉无关的位，得到特定的位。例如，掩码 0100 可以用来检查标志位 C 是否被置位： 1234// 判断是否含有FLAG_Cif (flags &amp; FLAG_C) &#123; // 0101 &amp; 0100 =&gt; 0100 =&gt; true // do stuff&#125; 一个有多个位被置位的掩码表达任一/或者的含义。例如，以下两个表达是等价的： 123456789101112// 如果我们有 FLAG_B 或者 FLAG_C 至少一个// (0101 &amp; 0010) || (0101 &amp; 0100) =&gt; 0000 || 0100 =&gt; trueif ((flags &amp; FLAG_B) || (flags &amp; FLAG_C)) &#123; // do stuff&#125;// 等价于var mask = FLAG_B | FLAG_C; // 0010 | 0100 =&gt; 0110if (flags &amp; mask) &#123; // 0101 &amp; 0110 =&gt; 0100 =&gt; true // do stuff&#125; 可以通过与掩码做或运算设置标志位，掩码中为 1 的位可以设置对应的位。例如掩码 1100 可用来设置位 C 和 D： 12var mask = FLAG_C | FLAG_D; // 0100 | 1000 =&gt; 1100flags |= mask; // 0101 | 1100 =&gt; 1101 可以通过与掩码做与运算清除标志位，掩码中为 0 的位可以设置对应的位。掩码可以通过对原语掩码做非运算得到。例如，掩码 1010 可以用来清除标志位 A 和 C ： 12var mask = ~(FLAG_A | FLAG_C); // ~0101 =&gt; 1010flags &amp;= mask; // 1101 &amp; 1010 =&gt; 1000 如上的掩码同样可以通过 ~FLAG_A &amp; ~FLAG_C 得到（德摩根定律）： 12var mask = ~FLAG_A &amp; ~FLAG_C;flags &amp;= mask; // 1101 &amp; 1010 =&gt; 1000 标志位可以使用异或运算切换。所有值为 1 的为可以切换对应的位。例如，掩码 0110 可以用来切换标志位 B 和 C： 12var mask = FLAG_B | FLAG_C;flags = flags ^ mask; // 1100 ^ 0110 =&gt; 1010 最后，所有标志位可以通过非运算翻转: 12// entering parallel universe...flags = ~flags; // ~1010 =&gt; 0101 位操作使用实例1.判断一个数a的奇偶：12345// 奇数a &amp; 1 === 1;// 偶数a &amp; 1 === 0; 2.两个整数x,y的平均值：1const avarage = (x, y) =&gt; (x &amp; y) + ((x ^ y) &gt;&gt; 1); 3.不使用缓存交换两个整数：1234567891011121314151617// 正常版本var swap1 = (x, y) =&gt; &#123; if (x !== y ) &#123; var z = x; x = y; y = z; &#125;&#125;// 使用位操作符var swap = (x, y) =&gt; &#123; if (x !== y ) &#123; x ^= y; y ^= x; x ^= y; &#125;&#125; 4.老鼠试毒：假设有1000杯水，其中有一杯有毒，至少用多少只老鼠试出哪杯有毒? 123456789101112131415161718192021222324252627282930// 使用位掩码解决// 假设共有8杯水，标记：var cup_a = 1; // 0001var cup_b = 2; // 0010var cup_c = 3; // 0011var cup_d = 4; // 0100var cup_e = 5; // 0101var cup_f = 6; // 0110var cup_g = 7; // 0111var cup_h = 8; // 1000// 转置矩阵可得：0000 00010001 11100110 01101010 10101234 5678// mouse_a = 8;mouse_b = 4 | 5 | 6 | 7;mouse_c = 2 | 3 | 6 | 7;mouse_d = 1 | 3 | 5 | 7;2^4 = 8;....2^10 = 1024也就是：0000000001，0000000010，0000000011，...，1111101000；道理同上。 5.权限问题：在实际开发中，我们常常遇到权限的判断的问题，比如说，不同的用户对系统有不同的操作权限，有的用户可能有多种权限，我们最常规的办法就是每一个权限定义一个BOOL值。假设，某系统有4种权限，那么，就有了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// var role = &#123;// a: &apos;a&apos;,// b: &apos;b&apos;,// c: &apos;c&apos;,// c: &apos;d&apos;,// &#125;;// 判断某用户有三种权限： role.a &amp;&amp; role.b &amp;&amp; role.c// 使用位操作：// var role = &#123;// a: 1 &lt;&lt; 0, // 0001// b: 1 &lt;&lt; 1, // 0010// c: 1 &lt;&lt; 2, // 0100// d: 1 &lt;&lt; 3, // 1000// &#125;// 判断某用户有三种权限： role.a | role.b | role.cvar role = &#123; a: 1 &lt;&lt; 0, // 0001 b: 1 &lt;&lt; 1, // 0010 c: 1 &lt;&lt; 2, // 0100 d: 1 &lt;&lt; 3, // 1000&#125;function Permission(flag)&#123; this.flag = flag;&#125;// 设置权限Permission.prototype.set = function(perm) &#123; this.flag = perm;&#125;// 添加一项或多项权限Permission.prototype.enable = function(perm) &#123; this.flag |= perm;&#125;// 删除一项或多项权限Permission.prototype.disable = function(perm) &#123; this.flag &amp;= ~perm;&#125;// 是否拥有某些权限Permission.prototype.has = function(perm) &#123; return (this.flag &amp; perm) === perm;&#125;// 是否禁用了某些权限Permission.prototype.not = function(prem) &#123; return (this.flag &amp; perm) === 0;&#125;// 是否仅仅拥有某些权限Permission.prototype.only = function(perm) &#123; return this.flag === perm;&#125;// 打印当前权限Permission.prototype.log = function() &#123; var perm_list_key = []; Object.keys(role).forEach(key =&gt; &#123; if(this.has(role[key]))&#123; perm_list_key.push(key); &#125; &#125;); console.log(&apos;当前权限:&apos;,perm_list_key.join(&apos;,&apos;)); return perm_list_key;&#125;var perm_a = new Permission(role.a | role.b | role.c);// perm_a.disable(role.a);console.log(perm_a); 通过位操作实现一个权限类]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS-React-Redux+Dva」前端项目实践总结]]></title>
    <url>%2FBlog%2F2018%2F12%2F27%2FfrontEndPractice%2F</url>
    <content type="text"><![CDATA[No.1 网页布局基础学习，实现静态聊天网页 任务1：使用HTML+CSS+JS完成一个本地聊天Demo（模仿JTalk-PC），达到输入文本信息后，展示带有样式的内容。 涉及内容： 认识HTML标签 学习css属性，了解css与html相互作用基础 了解网页骨架结构的搭建，学习骨架的搭建，组件的划分 认识javascript语法、函数、变量、数据类型、作用域、事件、运算符、字符串、调试、闭包、代码规范 了解flex布局方案，学习弹性布局的作用 布局调试工具的学习使用 重点： - Html元素类型：块级元素、内联元素(又叫行内元素)、内联块级元素。针对问题：开始时使用float浮动布局，因为这个方法破坏了文档流造成高度塌陷，出现多处定位问题，后仔细了解行内块级元素布局方法，完成页面布局。 内联元素（行内）：display：inline；/、、、、、、1、和其他元素都在一行上；2、元素的高度、宽度及顶部和底部边距不可设置；3、元素的宽度就是它包含的文字或图片的宽度，不可改变。 块级（独占一行）：display：block；/、、…、、、、、、 、1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（霸道，一个块级元素独占一行）2、元素的高度、宽度、行高以及顶和底边距都可设置。3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致） 行内块：display：inline-block；float:left / right；position：absolute/fixed;、1、和其他元素都在一行上；2、元素的高度、宽度、行高以及顶和底边距都可设置 - Flexbox 弹性布局针对问题：寻找将整个Div内容居中在屏幕中心的办法 No.2 React学习，使用React框架重构前期内容任务2：使用React重构完成Demo2，将网页组件化，并完成前端与服务器间的数据操作，做到用户输入消息，请求到服务器，并从服务器返回此消息作为回复。 涉及内容： 学习异步编程ajax、Promise、fetch、setTimeout、setInterval 根据之前的静态页面，实现静态页面的前端功能 认识React框架基础，掌握React生命周期，以及基本代码API React：//学习参考https://segmentfault.com/a/1190000012921279#articleHeader18 React是一个用来构建UI的JS库，满足前端组件化开发模式。 babel编译器和webpack打包工具封装在creat-react-app的脚手架中。 通过 JS函数 创建无状态组件，通过 class 创建有状态组件，以此将「单纯展示数据」的组件和「有业务逻辑、需要操作数据」的组件分离 重点： - React的生命周期组件的生命周期是从创建到挂载再到卸载的一个完整周期。这三个阶段总是伴随着组件各种各样的事件，这些事件被统称为组件的生命周期函数。 - 异步编程Javascript语言的执行环境是”单线程”，使用异步模式避免耗时长的操作造成浏览器失去响应。在Demo2中使用了Ajax操作。 AJAX：是一种在无需重新加载整个网页的情况之下能够更新部分网页的技术。GET - 从指定的资源请求数据POST - 向指定的资源提交要处理的数据 使用Ajax请求一个 JSON 数据一般是这样：123456789101112131415161718192021//创建XHR对象var xhr = new XMLHttpRequest();//规定请求的类型、URL 以及是否异步处理请求xhr.open(&apos;GET&apos;, url/file,true);//规定当服务器响应已做好被处理的准备时所执行的任务xhr.onreadystatechange = function() &#123; if(xhr.readyState==4)&#123; if(xhr.status==200)&#123; //获得字符串形式的响应数据。 var data=xhr.responseText; console.log(data); &#125;&#125;;xhr.onerror = function() &#123; console.log(&quot;Oh, error&quot;);&#125;;//将请求发送到服务器xhr.send(); 使用fetch请求JSON数据：12345678//解析为可读数据fetch(url).then(response =&gt; response.json()) //执行结果是 resolve就调用then方法 .then(data =&gt; console.log(data)) //执行结果是 reject就调用catch方法 .catch(err =&gt; console.log(&quot;Oh, error&quot;, err)) Fetch：语法简洁，更加语义化； 基于标准 Promise 实现。 Promise： fetch方法返回一个Promise对象, 根据 Promise Api 的特性, fetch可以方便地使用then方法将各个处理逻辑串起来, 使用 Promise.resolve() 或 Promise.reject() 方法将分别返会肯定结果的Promise或否定结果的Promise, 从而调用下一个then 或者 catch，catch用来指定reject的回调。 No.3 Redux、Dva学习，将Demo移植到项目中任务3：使用Dva完成Demo3，掌握一次开发的完整过程，在Demo3中完成发送一条消息，能够获取服务器的数据并进行回复展示。 涉及内容： 学习异步编程ajax、Promise、fetch、setTimeout、setInterval 根据之前的静态页面，实现静态页面的前端功能 认识React框架基础，掌握React生命周期，以及基本代码API 理解Redux概念和Dva概念 Redux：Redux 是 JavaScript 状态容器，在react项目中，搭配redux数据流开发，将UI层和数据层区分开。惟一改变 state 的办法是触发 action，通过编写 reducers 来描述 action 如何改变 state 。 对于没有父子关系的组件需要进行通信的情况，redux在组件树中使用store容器，令组件dispatch状态更改到store中。store中包含的就是更新state的reducers，使得所有的状态更改都通过单一store进行。容器组件使用 React Redux 的 connect() 方法来生成。 而Dva在redux数据流方案上，简化了开发体验，额外内置了 react-router 和 fetch。Dva 通过 model 的概念把一个领域的模型管理起来，包含同步更新 state 的 reducers，处理异步逻辑的 effects，订阅数据源的 subscriptions 。]]></content>
  </entry>
  <entry>
    <title><![CDATA[生成器基础和扩展]]></title>
    <url>%2FBlog%2F2018%2F11%2F11%2Fgenerator%2F</url>
    <content type="text"><![CDATA[生成器基础和扩展 可迭代协议和迭代器协议可迭代协议可迭代协议允许 JavaScript 对象去定义或定制它们的迭代行为, 例如（定义）在一个 for..of 结构中什么值可以被循环（得到）。一些内置类型都是内置的可迭代对象并且有默认的迭代行为, 比如 Array or Map, 另一些类型则不是 (比如Object) 。 为了变成可迭代对象， 一个对象必须实现 @@iterator 方法, 意思是这个对象（或者它原型链 prototype chain 上的某个对象）必须有一个名字是 Symbol.iterator 的属性: 属性 值 [Symbol.iterator] 返回一个对象的无参函数，被返回对象符合迭代器协议。 当一个对象需要被迭代的时候（比如开始用于一个for..of循环中），它的@@iterator方法被调用并且无参数，然后返回一个用于在迭代中获得值的迭代器。 迭代器协议该迭代器协议定义了一种标准的方式来产生一个有限或无限序列的值。 当一个对象被认为是一个迭代器时，它实现了一个 next() 的方法并且拥有以下含义： 属性: next 值：返回一个对象的无参函数，被返回对象拥有两个属性： done (boolean) 如果迭代器已经经过了被迭代序列时为 true。这时 value 可能描述了该迭代器的返回值。返回值在这里有更多解释。 如果迭代器可以产生序列中的下一个值，则为 false。这等效于连同 done 属性也不指定。 value - 迭代器返回的任何 JavaScript 值。done 为 true 时可省略。 迭代器它是一种接口，为各种不同的数据结构提供统一的访问机制。 Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。 ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。该迭代器可以被 for…of 循环使用。 原生具备 Iterator 接口的数据结构如下： Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 创建自定义迭代器1234567891011var myIterable = &#123; *[Symbol.iterator] ()&#123; yield 1; yield 2; yield 3; &#125;&#125;console.log([...myIterable]);for(let i of myIterable)&#123; console.log(i);&#125; Symbol.iterator迭代器代码示例 使用场合 结构赋值： 对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。 1234567let set = new Set().add(&apos;a&apos;).add(&apos;b&apos;).add(&apos;c&apos;);let [x,y] = set;// x=&apos;a&apos;; y=&apos;b&apos;let [first, ...rest] = set;// first=&apos;a&apos;; rest=[&apos;b&apos;,&apos;c&apos;]; spread运算符（…）： spread运算符（…）也会调用默认的 Iterator 接口。 12345678// 例一var str = &apos;hello&apos;;[...str] // [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]// 例二let arr = [&apos;b&apos;, &apos;c&apos;];[&apos;a&apos;, ...arr, &apos;d&apos;]// [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;] yield* 1234567891011121314let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator = generator();iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; 其他场合 for…of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])） Promise.all() Promise.race() 生成器生成器对象是由一个 generator function 返回的,并且它符合可迭代协议和迭代器协议。 语法12345678function *gen() &#123; yield 1; yield 2; yield 3;&#125;let g = gen(); // &quot;Generator &#123; &#125;&quot; 方法 Generator.prototype.next()：返回一个由 yield表达式生成的值。 Generator.prototype.return()：返回给定的值并结束生成器。 Generator.prototype.throw()： 向生成器抛出一个错误。 next()next() 方法返回一个包含属性 done 和 value 的对象。该方法也可以通过接受一个参数用以向生成器传值。 1gen.next(value) 参数value: 向生成器传递的值。 返回值： done(Boolean): 当迭代器遍历到迭代序列末端时返回值 true。此时，迭代器可以将返回值作为 value。 当迭代器仍可继续在迭代序列中向前遍历时返回值 false。这相当于不指定 done 属性。 value: 迭代器返回的任意的Javascript值。当 done 的值为 true 时可以忽略该值。 return()return() 方法返回给定的值并结束生成器。 1gen.return(value) value: 需要返回的值 返回值：{ value, done: true } throw()throw() 方法用来向生成器抛出异常，并恢复生成器的执行，返回带有 done 及 value 两个属性的对象。 1gen.throw(exception) exception：用于抛出的异常 返回值： done (boolean)： 如果迭代器已经返回了迭代序列的末尾，则值为 true。在这种情况下，可以指定迭代器 value 的返回值。 如果迭代能够继续生产在序列中的下一个值，则值为 false。 这相当与不指定 done 属性的值。 value - 迭代器返回的任何 JavaScript 值。当 done 是 true 的时候可以省略。 生成器函数function* 这种声明方式(function关键字后跟一个星号）会定义一个生成器函数 (generator function)，它返回一个 Generator 对象。 语法12345678910111213141516function *name([param[, param[, ... param]]]) &#123; statements &#125;或者new GeneratorFunction ([arg1[, arg2[, ...argN]],] functionBody)// arg1, arg2, ... argN: 参数 // 函数使用的名称作为形式参数名称。// 每个必须是一个字符串，// 对应于一个有效的JavaScript标识符或这样的字符串的列表，// 用逗号分隔；如“x”，“theValue”或“a,b”。// functionBody: 一个包含多条表示JavaScript函数体语句的字符串// 注意：GeneratorFunction并不是一个全局对象，通过：// Object.getPrototypeOf(function*()&#123;&#125;).constructor获取 描述 生成器函数在执行时能暂停，后面又能从暂停处继续执行。 调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的迭代器（iterator）对象。 当这个迭代器的 next()方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现yield的位置为止，yield 后紧跟迭代器要返回的值。或者如果用的是 yield*（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行） next()方法返回一个对象，这个对象包含两个属性：value 和 done，value 属性表示本次 yield 表达式的返回值，done 属性为布尔类型，表示生成器后续是否还有 yield 语句，即生成器函数是否已经执行完毕并返回 调用 next()方法时，如果传入了参数，那么这个参数会作为上一条执行的 yield 语句的返回值 generator 声明方式 生成器委托yield* 表达式用于委托给另一个generator 或可迭代对象 语法1yield* [[expression]]; expression： 返回一个可迭代对象的表达式。 描述 yield* 表达式迭代操作数，并产生它返回的每个值。 yield* 表达式本身的值是当迭代器关闭时返回的值（即done为true时）。 生成器委托 生成器委托传入值 生成器委托中含return 生成器委托throw 高级用法1.生成器的传入值与传出值12345678910function *foo(x) &#123; var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z);&#125;var it = foo( 5 );console.log( it.next() ); // &#123; value:6, done:false &#125;console.log( it.next( 12 ) ); // &#123; value:8, done:false &#125;console.log( it.next( 13 ) ); // &#123; value:42, done:true &#125; 2.错误处理123456789101112function *foo(x)&#123; try&#123; var a = yield x; console.log(&apos;a:&apos;, a); &#125; catch(e) &#123; console.log(&apos;err&apos;, e); &#125;&#125;var gen = foo(3);gen.next();gen.throw(&apos;ops!&apos;); 生成器的传入值与传出值 3.生成器自执行器1234567891011121314151617181920function run(genFuc, initialValue) &#123; const gen = genFuc(initialValue); iterate(gen); function iterate(gen) &#123; step(); function step(arg, isError) &#123; const &#123;value: express, done&#125; = isError ? gen.throw(arg) : gen.next(arg); let response; if (!done) &#123; if (typeof express === &apos;function&apos;) &#123; response = express(); &#125; else &#123; response = express; &#125; Promise.resolve(response).then(step, err =&gt; step(err, true)); &#125; &#125; &#125;&#125; 4.遍历一棵二叉树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Btree&#123; constructor(value, left=null, right=null) &#123; this.value = value; this.left = left; this.right = right; &#125; /** 默认先序 */ * [Symbol.iterator]() &#123; yield this.value; if (this.left) &#123; yield* this.left; &#125; if (this.right) &#123; yield* this.right; &#125; &#125; /** 先序遍历 */ *preOrder() &#123; yield console.log(this.value); if (this.left) &#123; yield *this.left.preOrder(); &#125; if (this.right) &#123; yield *this.right.preOrder(); &#125; &#125; /** 中序遍历 */ *inOrder() &#123; if(this.left)&#123; yield *this.left.inOrder(); &#125; yield console.log(this.value); if(this.right)&#123; yield *this.right.inOrder(); &#125; &#125; /** 后序遍历 */ *postOrder() &#123; if(this.left)&#123; yield *this.left.postOrder(); &#125; if(this.right)&#123; yield *this.right.postOrder(); &#125; yield console.log(this.value); &#125;&#125;let tree = new Btree(&apos;a&apos;, new Btree(&apos;b&apos;, new Btree(&apos;c&apos;), new Btree(&apos;d&apos;)), new Btree(&apos;e&apos;));for (let x of tree) &#123; console.log(x);&#125;// Output: a,b,c,d,e generator实现一棵二叉树的先中后序遍历 5.生成器的并发生成器的并发 async 函数async function是什么？其实就是generator的语法糖，即generator + 自动执行器。 async function对Generator 函数的改进，体现在： 内置执行器 更好的语义： async 和 await语法 返回值是Promise 语法12345678910async function name([param[, param[, ... param]]]) &#123; statements &#125;或者var name = async () =&gt; &#123;&#125;或者var AsyncFunction= Object.getPrototypeOf(async function()&#123;&#125;).constructor;var asyncInstance = new AsyncFunction([arg1[, arg2[, ...argN]],] functionBody)； 错误处理将async 函数内部的await语句用try…catch结构包裹. 123456789101112async f()&#123; try &#123; await f1(); await f2(); .... &#125; catch(err) &#123;// console.log(err);// 或者// return Promise.reject(err);// 再通过返回的Promise结果的catch方法捕获异常。 &#125;&#125; *异步迭代器异步迭代器的next()方法返回一个{ value, done } 的 promise。 12345678910111213 const asyncIter = &#123;- [Symbol.iterator]: () =&gt; &#123;+ [Symbol.asyncIterator]: () =&gt; &#123; const items = [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]; return &#123;- next: () =&gt; (&#123;+ next: () =&gt; Promise.resolve(&#123; done: items.length === 0, value: items.shift() &#125;) &#125; &#125; &#125; for await..of 用来遍历异步的 Iterator 接口。 ==for-await-of 只能在 async 函数或者 async 生成器里面使用==。 异步遍历器]]></content>
  </entry>
  <entry>
    <title><![CDATA[iconFont]]></title>
    <url>%2FBlog%2F2018%2F10%2F17%2FiconFont%2F</url>
    <content type="text"><![CDATA[1.原理1.1 系统字体计算机中，各种信息都是以二进制编码的形式存在的，不管是文字还是其它各种信息，在计算机中都是以０和１组成的二进制代码表示的，之所以能区别这些信息的不同，是因为它们采用的编码规则不同。英文字母用的是单字节的ASCII码，汉字采用的是双字节的汉字内码。 字符（英文，包括字母、数字、标点、运算符等）编码，国际通用的ASCII码； 汉字的编码 汉字内码； 汉字外码； 汉字字形码。 在计算机内表示汉字而统一的编码方式形成汉字编码叫内码（如国标码），内码是惟一的。为方便汉字输入而形成的汉字编码为输入码，属于汉字的外码，输入码因编码方式不同而不同，是多种多样的。为显示和打印输出汉字而形成的汉字编码为字形码，计算机通过汉字内码在字模库中找出汉字的字形码，实现其转换。 1.2 web字体css font-family 通过定义web上面文字的fontfamily,确定页面显示字体。 1234.font&#123; font-size: 16px; font-family: &apos;微软雅黑&apos;;&#125; 但是这种情况下只能用系统默认的一些字体，限制比较大。web前端工程师必须使用已在用户计算机上安装好的字体。 css3可以自定义字体，加载自己的字体，使用 @font-face 定义一个字体family： css @font-face 这是一个叫做CSS@规则，它允许网页开发者为其网页指定在线字体，通过这种作者自备字体的方式，@font-face可以消除对用户电脑字体的依赖。1234567891011@font-face &#123; [ font-family: &lt;family-name&gt;; ] || /* 必填。所指定的字体名字将会被用于font或font-family属性 */ [ src: &lt;src&gt;; ] || /* 必填。远程字体文件位置的URL或者用户计算机上的字体名称， 可以使用local语法通过名称指定用户的本地计算机上的字体( i.e. src: local(&apos;Arial&apos;); )。 如果找不到该字体，将会尝试其他来源，直到找到它。*/ [ unicode-range: &lt;unicode-range&gt;; ] || /* 可选。定义该字体支持Unicode字符的范围。默认值是&quot;ü+0-10 FFFF&quot;*/ [ font-weight: &lt;font-weight&gt;; ] || /* 可选。定义字体的粗细。默认值是&quot;正常&quot; */ [ font-style: &lt;font-style&gt;; ] /* 可选。定义该字体应该是怎样样式。默认值是&quot;正常&quot; */ [ font-variant: &lt;font-variant&gt;; ] || [ font-feature-settings: &lt;font-feature-settings&gt;; ] || [ font-variation-settings: &lt;font-variation-settings&gt;; ] || [ font-stretch: &lt;font-stretch&gt;; ] || /*可选。定义该字体应该如何被拉长。默认值是&quot;正常&quot;*/&#125; See the Pen MPQbKd by vivizhou0596 (@vivizhou0596) on CodePen. 使用示例 12345678910111213141516/* 定义字体 */@font-face &#123; font-family: &quot;iconfont&quot;; src: url(&apos;iconfont.eot?t=1538029788022&apos;); /* IE9*/ src: url(&apos;iconfont.eot?t=1538029788022#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */ url(&apos;data:application/x-font-woff;charset=utf-8;base64,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&apos;) format(&apos;woff&apos;), url(&apos;iconfont.ttf?t=1538029788022&apos;) format(&apos;truetype&apos;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url(&apos;iconfont.svg?t=1538029788022#iconfont&apos;) format(&apos;svg&apos;); /* iOS 4.1- */&#125;/* 使用字体 */.iconfont &#123; font-family:&quot;iconfont&quot; !important; font-size:16px; font-style:normal;&#125; *注释： Firefox、Chrome、Safari 以及 Opera 支持 .ttf (True Type Fonts) 和 .otf (OpenType Fonts) 类型的字体。 Internet Explorer 9+ 支持新的 @font-face 规则，但是仅支持 .eot 类型的字体 (Embedded OpenType)。 Internet Explorer 8 以及更早的版本不支持新的 @font-face 规则。 2.实践##2.1 创建项目，引用图标先在阿里巴巴矢量图形库创建一个项目，添加一些图标。然后帮项目下载下来。 解压缩阿里图标库下载的文件，生成目录结构如下的文件夹： 12345678910-fontIcon--demo_fontclass.html--demo_symbol.html--demo_unicode.html--iconfont.css--iconfont.eot--iconfont.js--iconfont.svg--iconfont.tty--iconfont.woff css、html、js文件，是关于使用的说明和demo； ttf、eot、woff、svg字体文件，最常用的ttf文件，另外三个是为了兼容不同的浏览器而额外引入的。 2.2 解析字体文件工具软件：FontForge按如下步骤操作，查看系统的calibri字体：1.打开控制面板-字体-找到calibri字体，将文件拷到新的文件夹中;2.使用FontoForge打开calibri文件，会看到如下一张表； 字体文件就是这样以unicode作为索引的字形表，双击里面的某个字形，可以对它进行编辑，每个字形其实就是一个矢量图，因此ttf文件所表示的字库也叫矢量字库； 与之对应的另一种字库——点阵字库，两者最大的区别就是点阵字库可以在Console Mode（命令行模式）下被渲染出来，而矢量字库必须在Graphics Mode（图形模式）中被渲染。 2.3 字体定义打开iconfont.css，可以看到 @font-face 声明，前文提到的自定义字体的声明，其中font-family属性定义了这个字体的名称，src属性定义了该要渲染字体需要下载的字体文件。 1234567@font-face &#123;font-family: &quot;iconfont&quot;; src: url(&apos;iconfont.eot?t=1537518751733&apos;); /* IE9*/ src: url(&apos;iconfont.eot?t=1537518751733#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */ url(&apos;data:application/x-font-woff;charset=utf-8;base64,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&apos;) format(&apos;woff&apos;), url(&apos;iconfont.ttf?t=1537518751733&apos;) format(&apos;truetype&apos;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url(&apos;iconfont.svg?t=1537518751733#iconfont&apos;) format(&apos;svg&apos;); /* iOS 4.1- */&#125; 为何有两个src？ 1绝大多数情况下，第一个 src 是可以去掉的，除非需要支持 IE9 下的兼容模式。在 IE9 中可以使用 IE7 和 IE8 的模式渲染页面，微软修改了在兼容模式下的 CSS 解析器，导致使用 ? 的方案失效。由于 CSS 解释器是从下往上解析的，所以在上面添加一个不带问号的 src 属性便可以解决此问题。 #iefix有何作用？1IE9 之前的版本没有按照标准解析字体声明，当 src 属性包含多个 url 时，它无法正确的解析而返回 404 错误，而其他浏览器会自动采用自己适用的 url。因此把仅 IE9 之前支持的 EOT 格式放在第一位，然后在 url 后加上 ?，这样 IE9 之前的版本会把问号之后的内容当作 url 的参数。至于 #iefix 的作用，一是起到了注释的作用，二是可以将 url 参数变为锚点，减少发送给服务器的字符。 后面的src和一堆url主要是为了兼容不同的浏览器，format属性告诉浏览器这个字体的格式，可选的字体格式有 woff、woff2、truetype、opentype、embedded-opentype、svg。 2.4 字体使用 阿里提供Unicode、Font-class、Symbol三种引用方式。 2.4.1 Unicode 1234567891011/* HTML */ &lt;i class=&quot;iconfont&quot;&gt;&amp;#xe626;&lt;/i&gt;/* css */ .iconfont &#123; font-family:&quot;iconfont&quot; !important; font-size:16px; font-style:normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; &#125; html中’&#xe626;’其中&amp;表示转义，#x可以用于表示16进制转义字符（Unicode主流的规范是UCS-2，即3个字节表示一个字符，所以unicode字符可以用一个16进制数表示）。 事实上，你也可以用“&amp;#”对10进制的数进行转义，比如0xe626用十进制表示为58918，在html中你就可以这么写：1&lt;i class=&quot;icon testfont&quot;&gt;&amp;#58918;&lt;/i&gt; 我们可以直接从下载的demo_unicode.html文件中找到该图标对应的16进制数；如果你想对这个图形做一些修改，可以用fontForge打开字体文件，接着根据16进制数或者图标名字来定位到该图标：当在你在FontForge中修改了字形后，点击File-&gt;Generage Fonts.. 生成字体文件（记住每种格式导出一份），然后在font-face中修改文件的引用地址即可。 2.4.2 Font-class这种引入方式和原理第一种类似 12345/* html */ &lt;i class=&quot;iconfont icon-guanbi&quot;&gt;&lt;/i&gt;/* css */ .icon-guanbi:before &#123; content: &quot;\e626&quot;; &#125; 这种方式只是在原来的dom上增加一个伪元素，css中正斜杠\表示一个16进制数字。这样写的好处是可以直接通过审查dom元素就知道它引用的是哪个字形，看起来更加语义化。 2.4.3 Symbol iconfont事实上使用的是使用系统字体渲染引擎，而它是只支持单色的。 官网称Symbol可以实现多色，如何做到的呢？以下是官网对其的描述：123456这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。这种用法其实是做了一个svg的集合，与另外两种相比具有如下特点：- 支持多色图标了，不再受单色限制。- 通过一些技巧，支持像字体那样，通过font-size,color来调整样式。- 兼容性较差，支持 ie9+,及现代浏览器。- 浏览器渲染svg的性能一般，还不如png。 使用步骤如下： 第一步：引入项目下面生成的symbol代码：1&lt;script src=&quot;./iconfont.js&quot;&gt;&lt;/script&gt; 第二步：加入通用css代码（引入一次就行）：12345678910111213&lt;style type=&quot;text/css&quot;&gt; .icon &#123; /* 通过设置 font-size 来改变图标大小 */ width: 1em; height: 1em; /* 图标和文字相邻时，垂直对齐 */ vertical-align: -0.15em; /* 通过设置 color 来改变 SVG 的颜色/fill */ fill: currentColor; /* path 和 stroke 溢出 viewBox 部分在 IE 下会显示 normalize.css 中也包含这行 */ overflow: hidden; &#125;&lt;/style&gt; 第三步：挑选相应图标并获取类名，应用于页面：123&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt; &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;&lt;/svg&gt; 这里使用了SVG-Sprite，所以使用了js文件将svg嵌入了文档中而不是单独拿出来，因为SVG Sprite只能在同一个文档中使用svg的symbol。因为svg的大小不是不支持font-size修改的，这里用了一个比较hack的方式，就是把图标元素的宽高都写为1em，而em的大小是相对于该元素的字体大小的，这样就实现了svg宽高跟着svg的字体大小一起变了。 3. SVG Sprite:3.1 概述SVG Sprite类似于CSS中的Sprite技术，图标图形整合在一起，实际呈现的时候准确显示特定图标。 123456789101112131415161718192021222324&lt;div&gt; &lt;div&gt; &lt;svg&gt; &lt;!-- 定义图形对象以供重复使用 --&gt; &lt;defs&gt; &lt;g id=&quot;shape&quot;&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;50&quot; height=&quot;50&quot; /&gt; &lt;circle cx=&quot;0&quot; cy=&quot;0&quot; r=&quot;50&quot; /&gt; &lt;/g&gt; &lt;/defs&gt; &lt;!-- 从svg文档中获取节点，并复制使用 --&gt; &lt;use xlink:href=&quot;#shape&quot; x=&quot;50&quot; y=&quot;50&quot; /&gt; &lt;use xlink:href=&quot;#shape&quot; x=&quot;200&quot; y=&quot;50&quot; /&gt; &lt;/svg&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;垮SVG调用&lt;/h1&gt; &lt;!-- SVG中的use元素可以调用其他SVG文件的元素，只要在一个文档中。 --&gt; &lt;svg width=&quot;500&quot; height=&quot;110&quot;&gt; &lt;use xlink:href=&quot;#shape&quot; x=&quot;50&quot; y=&quot;50&quot; /&gt; &lt;/svg&gt; &lt;/div&gt;&lt;/div&gt; 小结： 跨SVG调用就是“SVG Sprite技术”的核心所在。 在页面载入一个充满Sprite(symbol)的SVG文件（或直接include SVG代码），在页面的任何角落，只要想使用这个图标，通过svg-&gt;use即可。 图标尺寸CSS控制，里面只有一个仅有xlink:href属性的use元素。 3.1 SVG Sprite实际应用3.1.1 svg图标来源 拿来主义,在图库下载 阿里巴巴矢量图标库 icoMoon 自己动手丰衣足食，使用专业的绘图工具[Adobe Illustrator]手动绘制 ###3.1.1 合并svg图标 站在巨人肩膀上使用阿里巴巴矢量图标库或者icoMoon专业矢量图标网站； 自己动手丰衣足食 svg-sprite-loader实现自己的icon组件 原理：利用svg的symbol元素，将每个icon包括在symbol中，通过use元素使用该symbol. 配置步骤如下： 1、安装svg-sprite-loader，配置webpack rules 123456789// 安装 svg-sprite-loader npm install svg-sprite-loader --save // 配置webpack rules&#123; test: /\.svg$/, use:[&#123;loader: &apos;svg-sprite-loader&apos;&#125;],&#125; svg-sprite-loader会把icon塞到一个个symbol中，symbol的id如果不特别指定，就是文件名。它最终会在你的html中嵌入一个svg，你就可以像这样： 使用icon了。 2、引入svg文件 123456789//引入 svgimport default32 from &apos;./icons/assets/default32.svg&apos;;// 使用icon&lt;div&gt; &lt;svg&gt; &lt;use xlinkHref=&#123;`#$&#123;default32.id&#125;`&#125; /&gt; &lt;/svg&gt;&lt;/div&gt; 上面我们的基本功能已经完成了，还有最后一个小小的问题——我们每次引用一个文件的时候就得import一下，这还是很麻烦也不利于项目的管理。 在这里，我们可以使用webpack的require.contextAPI来动态引入所有的Icon. 现在我们是不能动态引入模块，但是webpack为我们提供了相关功能，webpack允许我们使用表达式动态引入模块。比如：require(‘./template/‘+name+’.ejs’);此时webpack会生成一个context module 它接受三个参数，第一个是文件夹，第二个是是否使用子文件，第三个是文件匹配的正则。 1require.context(directory, useSubdirectories = false, regExp = /^\.\//) require.context会返回一个函数，并且该函数有keys()，id，resolve()属性。 keys()方法返回的该模块可以处理的所有可能请求的模块的数组，简单一点就是满足该参数的模块； resolve()返回的是请求的module的id; id是该context module的id; 相关api可以查阅webpack关于require-context 3、组件化 12345678910111213141516171819202122232425// ./icon/index.js 动态引入所有的svg icon // requires and returns all modules that match const requireAll = requireContext =&gt; requireContext.keys().map(requireContext); // import all svg const req = require.context(&apos;./assets&apos;, false, /\.svg$/); export default requireAll(req);// ./Icon.jsx import React,&#123;Component&#125; from &apos;react&apos; import iconImg from &apos;./icons/index.js&apos;; export default class Icon extends Component&#123; render()&#123; const &#123; name &#125; = this.props; const symbolId = iconImg.find((&#123;default:&#123;id&#125;&#125;)=&gt;id===name) return ( &lt;div&gt; &lt;svg&gt; &lt;use xlinkHref=&#123;`#$&#123;symbolId.default.id&#125;`&#125; /&gt; &lt;/svg&gt; &lt;/div&gt; ) &#125; &#125; 小结 @font-face 自定义一个字体； Unicode、Font-class、Symbol引入字体； SVG Sprite 原理及应用。 参考链接： 浏览器字体渲染 使用阿里矢量图标库操作流程 SVG Sprite技术介绍 真正了解CSS3背景下的@font face规则 webpack插件svg-sprite-loader–实现自己的icon组件]]></content>
  </entry>
  <entry>
    <title><![CDATA[css属性:动画(Animation)]]></title>
    <url>%2FBlog%2F2018%2F09%2F28%2Fanimation%2F</url>
    <content type="text"><![CDATA[参考链接： css.doyoe.com css2.1中文版 MDN animation 概述 animation属性是如下属性的一个简写属性形式: animation-name: 检索或设置对象所应用的动画名称 animation-duration: 检索或设置对象动画的持续时间 animation-timing-function: 检索或设置对象动画的过渡类型 animation-delay: 检索或设置对象动画延迟的时间 animation-iteration-count: 检索或设置对象动画的循环次数 animation-direction: 检索或设置对象动画在循环中是否反向运动 animation-fill-mode: 检索或设置对象动画时间之外的状态 animation-play-state: 检索或设置对象动画的状态。w3c正考虑是否将该属性移除，因为动画的状态可以通过其它的方式实现，比如重设样式 123456默认值： 看每个独立属性适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 看每个独立属性媒体： 视觉 animation-name概述animation-name属性指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列 1234567默认值： none适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 视觉相关属性： [ @keyframes ] 示例1234567891011121314/* Single animation */animation-name: none;animation-name: test_05;animation-name: -specific;animation-name: sliding-vertically;/* Multiple animations */animation-name: test1, animation4;animation-name: none, -moz-specific, sliding;/* Global values */animation-name: initialanimation-name: inheritanimation-name: unset 语法 none: 特殊关键字，表示无关键帧。可以不改变其他标识符的顺序而使动画失效，或者使层叠的动画样式失效。 &lt;IDENT&gt;: 标识动画的字符串，由大小写不敏感的字母a-z、数字0-9、下划线(_)和/或横线(-)组成。第一个非横线字符必须是字母，数字不能在字母前面，不允许两个横线出现在开始位置。 animation-duration概述animation-duration属性指定一个动画周期的时长。默认值为0s，表示无动画。 123456默认值： 0s适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 视觉 语法 &lt;time&gt;：一个动画周期的时长，单位为秒(s)或者毫秒(ms)，无单位值无效。 1234animation-duration: 6sanimation-duration: 120msanimation-duration: 1s, 15sanimation-duration: 10s, 30s, 230ms animation-timing-function概述animation-timing-function属性定义CSS动画在每一动画周期中执行的节奏。可能值为一或多个 &lt;timing-function&gt;。 123456默认值： ease适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 视觉 语法123456789101112131415161718192021/* Keyword values */animation-timing-function: ease;animation-timing-function: ease-in;animation-timing-function: ease-out;animation-timing-function: ease-in-out;animation-timing-function: linear;animation-timing-function: step-start;animation-timing-function: step-end;/* Function values */animation-timing-function: cubic-bezier(0.1, 0.7, 1.0, 0.1);animation-timing-function: steps(4, end);animation-timing-function: frames(10);/* Multiple animations */animation-timing-function: ease, step-start, cubic-bezier(0.1, 0.7, 1.0, 0.1);/* Global values */animation-timing-function: inherit;animation-timing-function: initial;animation-timing-function: unset; &lt;timing-function&gt; linear：线性过渡。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0) ease：平滑过渡。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0) ease-in：由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0) ease-out：由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0) ease-in-out：由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) step-start：等同于 steps(1, start) step-end：等同于 steps(1, end) steps([, [ start | end ] ]?)：接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是start或end，指定每一步的值发生变化的时间点。第二个参数是可选的，默认值为end。 cubic-bezier(, , , )：特定的贝塞尔曲线类型，4个数值需在[0, 1]区间内 animation-delay概述animation-delay属性定义动画于何时开始，即从动画应用在元素上到动画开始的这段时间的延迟多久。 123456默认值： 0s适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 视觉 0s是该属性的默认值，代表动画在应用到元素上后立即开始执行。否则，该属性的值代表动画样式应用到元素上后会延迟执行； 定义一个负值会让动画立即开始。但是动画会从它的动画序列中某位置开始。例如，如果设定值为-1s，动画会从它的动画序列的第1秒位置处立即开始。 如果为动画延迟指定了一个负值，但起始值是隐藏的，则从动画应用于元素的那一刻起就获取起始值。 语法12animation-delay: 3s;animation-delay: 2s, 4ms; &lt;time&gt;从动画样式应用到元素上到元素开始执行动画的时间差（延迟）。该值可用单位为秒(s)和毫秒(ms)。如果未设置单位，定义无效。 animation-iteration-count概述animation-iteration-count属性定义动画循环播放的次数。默认次数为1。 123456默认值： 1适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 视觉 语法1234animation-iteration-count: infinite;animation-iteration-count: 3;animation-iteration-count: 2.3;animation-iteration-count: 2, 0, infinite; infinite: 无限循环播放。 &lt;number&gt;: 动画播放的次数 不可为负值。 可以用小数定义循环(0.5 将播放动画到关键帧的一半（from 0 ~ 50%)。 animation-direction概述animation-direction 属性指示动画是否反向播放。 123456默认值： normal适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 视觉 语法123456animation-direction: normalanimation-direction: reverseanimation-direction: alternateanimation-direction: alternate-reverseanimation-direction: normal, reverseanimation-direction: alternate, reverse, normal normal: 每个循环内动画向前循环，换言之，每个动画循环结束，动画重置到起点重新开始，这是默认属性 alternate: 动画交替反向运行，反向运行时，动画按步后退，同时，带时间功能的函数也反向，比如，ease-in 在反向时成为ease-out。计数取决于开始时是奇数迭代还是偶数迭代 reverse: 反向运行动画，每周期结束动画由尾到头运行 alternate-reverse: 反向交替， 反向开始交替。动画第一次运行时是反向的，然后下一次是正向，后面依次循环。决定奇数次或偶数次的计数从1开始 animation-play-state概述animation-play-state 属性定义一个动画是否运行或者暂停。 可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。 恢复一个已暂停的动画，将从它开始暂停的时候，而不是从动画序列的起点开始在动画。 语法1234567891011/* Single animation */animation-play-state: running;animation-play-state: paused;/* Multiple animations */animation-play-state: paused, running, running;/* Global values */animation-play-state: inherited;animation-play-state: initial;animation-play-state: unset; running: 运行 paused： 停止 animation-fill-mode概述animation-fill-mode 属性用来指定在动画执行之前和之后如何给动画的目标应用样式。 123456默认值： none适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 视觉 语法123456789animation-fill-mode: noneanimation-fill-mode: forwardsanimation-fill-mode: backwardsanimation-fill-mode: both/* 可以应用多个参数，这个时候使用逗号隔开 *//* 各个参数应用于与次序相对应的动画名 */animation-fill-mode: none, backwardsanimation-fill-mode: both, forwards, none none: 默认值。不设置对象动画之外的状态 forwards: 目标保持动画最后一帧的样式，最后一帧是哪个取决于animation-direction和 animation-iteration-count: animation-direction animation-iteration-count last keyframe encountered normal even or odd 100% or to reverse even or odd 0% or from alternate even 0% or from alternate odd 100% or to alternate-reverse even 100% or to alternate-reverse odd 0% or from backwards: 动画采用相应第一帧的样式，保持 animation-delay，第一帧取法如下： animation-direction first relevant keyframe normal or alternate 0% or from reverse or alternate-reverse 100% or to both: 动画将会执行 forwards 和 backwards 执行的动作。 @keyframe 关键帧概述@keyframes 规则通过在动画序列中定义关键帧（或waypoints）的样式来控制CSS动画序列中的中间步骤。 @keyframes定义的动画名称用来被animation-name所使用 定义动画时，简单的动画可以直接使用关键字from和to，即从一种状态过渡到另一种状态 如果复杂的动画，可以混合去设置某个时间段内的任意时间点的样式 当然，也可以不使用关键字from和to，而都使用 注意： ==让关键帧序列生效== 如果一个关键帧规则没有指定动画的开始或结束状态（也就是，0%/from 和100%/to，浏览器将使用元素的现有样式作为起始/结束状态。这可以用来从初始状态开始元素动画，最终返回初始状态。 如果在关键帧的样式中使用了不能用作动画的属性，那么这些属性会被忽略掉，支持动画的属性仍然是有效的，不受波及。 ==重复定义(Duplicate resolution)== 如果多个关键帧使用同一个名称，以最后一次定义的为准。 @keyframes 不存在层叠样式(cascade)的情况，所以动画在一个时刻（阶段）只会使用一个的关键帧的数据。 如果一个@keyframes 里的关键帧的百分比存在重复的情况，以最后一次定义的关键帧为准。 因为@keyframes 的规则不存在层叠样式(cascade)的情况，即使多个关键帧设置相同的百分值也不会全部执行。 ==属性个数不定== 如果一个关键帧中没有出现其他关键帧中的属性，那么这个属性将使用插值(不能使用插值的属性除外, 这些属性会被忽略掉) 1234567@keyframes identifier &#123; 0% &#123; top: 0; left: 0; &#125; 30% &#123; top: 50px; &#125; 68%, 72% &#123; left: 50px; &#125; 100% &#123; top: 100px; left: 100%; &#125;&#125;//例子中，&quot;top&quot;属性分别出现在 0%, 30%和100%的关键帧中，&quot;left&quot;属性分别出现在0%, 68%和100% 关键帧中. ==当关键帧被重复定义== 如果某一个关键帧出现了重复的定义，且重复的关键帧中的css属性值不同，以最后一次定义的属性为准。 ==关键帧中的 !important 关键词== 关键帧中出现的 !important 关键词将会被忽略 123456789101112@keyframes important1 &#123; from &#123; margin-top: 50px; &#125; 50% &#123; margin-top: 150px !important; &#125; /* 忽略 */ to &#123; margin-top: 100px; &#125;&#125;@keyframes important2 &#123; from &#123; margin-top: 50px; margin-bottom: 100px; &#125; to &#123; margin-top: 150px !important; /* 忽略 */ margin-bottom: 50px; &#125;&#125; 语法 &lt;identifier&gt;帧列表的名称。 名称必须符合 CSS 语法中对标识符的定义。 from等效于 0%. to等效于 100%. &lt;percentage&gt;动画序列中，触发关键帧的时间点，使用百分值来表示。 animation代码实例，旋转的正方体 系列动画]]></content>
  </entry>
  <entry>
    <title><![CDATA[css属性:变化(Transform)]]></title>
    <url>%2FBlog%2F2018%2F09%2F27%2Ftransform%2F</url>
    <content type="text"><![CDATA[参考链接： css.doyoe.com css2.1中文版 MDN transform 概述 transform 属性允许你修改CSS视觉格式模型的坐标空间。使用它，元素可以被转换（translate）、旋转（rotate）、缩放（scale）、倾斜（skew） CSS transform 属性 , 只对 block 级元素生效！ 123456初始值 none适用元素 可变换元素是否是继承属性 否适用媒体 视觉计算值 指定值，但相对长度会转换为绝对长度动画性 是 示例123456789101112131415161718192021222324252627282930313233/* Keyword values */transform: none;/* Function values */transform: matrix(1.0, 2.0, 3.0, 4.0, 5.0, 6.0);transform: translate(12px, 50%);transform: translateX(2em);transform: translateY(3in);transform: scale(2, 0.5);transform: scaleX(2);transform: scaleY(0.5);transform: rotate(0.5turn);transform: skew(30deg, 20deg);transform: skewX(30deg);transform: skewY(1.07rad);transform: matrix3d(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0);transform: translate3d(12px, 50%, 3em);transform: translateZ(2px);transform: scale3d(2.5, 1.2, 0.3);transform: scaleZ(0.3);transform: rotate3d(1, 2.0, 3.0, 10deg);transform: rotateX(10deg);transform: rotateY(10deg);transform: rotateZ(10deg);transform: perspective(17px);/* Multiple function values */transform: translateX(10px) rotate(10deg) translateY(5px);/* Global values */transform: inherit;transform: initial;transform: unset; 语法 &lt;transform-function&gt;至少一个 CSS transform functions 被应用 none指定为 不应用transform 2D变化 matrix() 用六个指定的值来指定一个均匀的二维（2D）变换矩阵 12345678910111213141516171819transform: matrix(a, c, b, d, tx, ty)/* a, b, c, d 创建了变形矩阵 ┌ ┐ │ a b │ │ c d │ └ ┘ tx, ty是变形的值 . */ 1.平移效果：transform: matrix(1, 0, 0, 1, tx, ty);等同于transform：translate(tx, ty);2.缩放效果：transform: matrix(sx,0,0,sy,0,0); 等同于transform：scale(sx, sy);3.旋转效果：transform: matrix(cosθ,sinθ,-sinθ,cosθ,0,0); 等同于transform：rotate(θ); 4.拉伸效果：transform：matrix(1,tan(θy),tan(θx),1,0,0); 等同于transform: skew(θx + &quot;deg&quot;，θy+ &quot;deg&quot;); css transform matrix 工具 translate() 指定对象的2D translation（2D平移）。第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则默认值为0 translateX() 指定对象X轴（水平方向）的平移，translate(tx, 0) 的简写形式 translateY() 指定对象Y轴（垂直方向）的平移，translate(0, ty)的简写形式 rotate() 指定对象的2D rotation（2D旋转），需先有 &lt;’ transform-origin ‘&gt; 属性的定义。移动量由指定角度定义;如果为正值，则运动将为顺时针，如果为负值，则为逆时针 。 180°的旋转称为点反射 (point reflection)。 12rotate(&lt;angle&gt;)&lt;angle&gt; 代表旋转的角度。正角表示顺时针旋转，负角表示逆时针旋转 scale() 指定对象的2D scale（2D缩放）。第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则默认取第一个参数的值。 当超出 [-1, 1]范围外时，缩放将在坐标方向上放大元素；当在该范围内时，它在该方向收缩元素。当等于1时，它什么也不做，当它为负时，它执行点反射和大小修改。 12scale(sx) orscale(sx, sy) scaleX() 指定对象X轴的（水平方向）缩放 scaleX(sx) 是 scale(sx, 1) 和 scale3d(sx, 1, 1) 的简写形式。 scaleX(-1) 表示通过原点的垂直轴定义轴对称（由 transform-origin 属性指定）。 scaleY() 指定对象Y轴的（垂直方向）缩放 scaleY(sy) 是 scale(1, sy) 和 scale3d(1, sy, 1) 的简写形式。 scaleY(-1) 定义了通过原点的水平轴的轴对称（由 transform-origin 属性指定）。 skew() 指定对象skew transformation（斜切扭曲）。第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则默认值为0 ==注意css斜切坐标系的x，y轴== skewX()指定对象X轴的（水平方向）扭曲 skewY()指定对象Y轴的（垂直方向）扭曲 Transform 2D 代码演示 3D变化 matrix3d() 用一个 4 × 4 的齐次矩阵来描述一个三维（3D）变换 123456789101112131415161718192021transform: matrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4);1.平移变换X, 对应translateX(tx)：matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, 0, 0, 1)2.平移变换Y, 对应translateY(ty)：matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, ty, 0, 1)3.平移变换，对应translateZ(tz)：matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, tz, 1)4.多维平移:matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,tx,ty,tz,1)5.多维尺度：matrix3d(cx, 0, 0, 0, 0, cy, 0, 0, 0, 0, cz, 0, 0, 0, 0, 1 );6.旋转变换：X轴：matrix3d(1,0,0,0,0,cos(θ),sin(θ),0,0,-sin(θ),cos(θ),0,0,0,0,1);Y轴：matrix3d(cos(θ),0,-sin(θ),0,0,1,0,0,sin(θ),0,cos(θ),0,0,0,0,1);Z轴：matrix3d(cos(θ),sin(θ),0,0,-sin(θ),cos(θ),0,0,0,0,1,0,0,0,0,1); translate3d() 指定对象的3D位移。第1个参数对应X轴，第2个参数对应Y轴，第3个参数对应Z轴，参数不允许省略 Transform 3D 代码演示 transform-origin概述transform-origin 属性让你更改一个元素变形的原点。 123456初始值 50% 50% 0适用于 可变换元素是否可继承 否适用媒体 视觉计算值 除了指定绝对值，否则都为百分比动画性 当值为数值时 示例1234567891011121314151617181920212223242526272829303132/* One-value syntax */transform-origin: 2px;transform-origin: bottom;/* x-offset | y-offset */transform-origin: 3cm 2px;/* x-offset-keyword | y-offset */transform-origin: left 2px;/* x-offset-keyword | y-offset-keyword */transform-origin: right top;/* y-offset-keyword | x-offset-keyword */transform-origin: top right;/* x-offset | y-offset | z-offset */transform-origin: 2px 30% 10px;/* x-offset-keyword | y-offset | z-offset */transform-origin: left 5px -3px;/* x-offset-keyword | y-offset-keyword | z-offset */transform-origin: right bottom 2cm;/* y-offset-keyword | x-offset-keyword | z-offset */transform-origin: bottom right 2cm;/* Global values */transform-origin: inherit;transform-origin: initial;transform-origin: unset; transform-origin属性可以使用一个，两个或三个值来指定，其中每个值都表示一个偏移量。 没有明确定义的偏移将重置为其对应的初始值。 如果定义了两个或更多值并且没有值的关键字，或者唯一使用的关键字是center，则第一个值表示水平偏移量，第二个值表示垂直偏移量。 一个值： 必须是，，或 left, center, right, top, bottom关键字中的一个。 两个值： 其中一个必须是，，或left, center, right关键字中的一个。 另一个必须是，，或top, center, bottom关键字中的一个。 三个值： 前两个值和只有两个值时的用法相同。 第三个值必须是。它始终代表Z轴偏移量。 语法 x-offset 定义变形中心距离盒模型的左侧的或偏移值。 offset-keyword left，right，top，bottom或center中之一，定义相对应的变形中心偏移。 y-offset 定义变形中心距离盒模型的顶的或偏移值。 x-offset-keyword left，right或center中之一，定义相对应的变形中心偏移。 y-offset-keyword top，bottom或center中之一，定义相对应的变形中心偏移。 z-offset 定义变形中心距离用户视线（z=0处）的（不能是）偏移值。 keyword value left 0% center 50% right 100% top 0% bottom 100% transform-origin 代码示例 transform-style概述123456初始值 flat适用元素 可变换元素是否是继承属性 否适用媒体 视觉计算值 指定值动画性 否 示例1234transform-style: preserve-3dtransform-style: flattransform-style: inherit 语法 preserve-3d 指定子元素定位在三维空间内 flat 指定子元素位于此元素所在平面内 perspective概述 perspective 属性指定了观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。z&gt;0的三维元素比正常大，而z&lt;0时则比正常小，大小程度由该属性的值决定。 三维元素在观察者后面的部分不会绘制出来，即z轴坐标值大于perspective属性值的部分。 默认情况下，消失点位于元素的中心，但是可以通过设置perspective-origin属性来改变其位置。 当该属性值不为0和none时，会创建新的层叠上下文。 123456默认值： none适用于： 变换元素继承性： 无动画性： 当值为&lt;length&gt;时计算值： 绝对长度或「none」媒体： 视觉 示例1234567891011/* Keyword value */perspective: none;/* &lt;length&gt; values */perspective: 20px; perspective: 3.5em;/* Global values */perspective: inherit;perspective: initial;perspective: unset; perspective 代码实例 perspective-origin概述perspective-origin属性决定了观察者正在观看的位置，即灭点(vanishing point)位置。 123456默认值 50% 50%，效果等同于center center适用于 可变换元素继承性 无动画性 当值为数值时计算值 除了指定绝对值，否则都为百分比媒体 视觉 示例1234567891011121314/* One-value syntax */perspective-origin: x-position;/* Two-value syntax */perspective-origin: x-position y-position;/* When both x-position and y-position are keywords, the following is also valid */perspective-origin: y-position x-position;/* Global values */perspective-origin: inherit;perspective-origin: initial;perspective-origin: unset; 该属性提供2个参数值。 如果提供两个，第一个用于横坐标，第二个用于纵坐标。 如果只提供一个，该值将用于横坐标；纵坐标将默认为center。 语法 x-position指定消失点的横坐标，其值有以下形式： 百分比，相对于元素宽度，可为负值。 长度值，可为负值。 left，关键字，0值的简记。 center，关键字，50%的简记。 right，关键字，100%的简记。 y-position指定消失点的纵坐标，其值有以下形式： - 百分比，相对于元素的高度，可为负值。 长度值，可为负值。 top，关键字，0值得简记。 center，关键字，50%的简记。 bottom，关键字，100%的简记。 perspective-origin代码示例 backface-visibility概述backface-visibility属性指定当元素背面朝向观察者时是否可见。元素的背面总是透明的，当其朝向观察者时，显示正面的镜像。 决定一个元素背面面向用户时是否可见，需要直接在该元素上定义backface-visibility属性，而不能在其父元素上，因为该属性默认为不可继承。 因为2D变换无透视效果，故该属性对2D变换无效。 123456默认值 visible适用于 变换元素继承性 无动画性 否计算值 指定值媒体 视觉 示例12backface-visibility: visiblebackface-visibility: hidden 语法 visible：指定元素背面可见，允许显示正面的镜像。 hidden：指定元素背面不可见 backface-visibility代码实例]]></content>
  </entry>
  <entry>
    <title><![CDATA[css属性:过渡(Transition)]]></title>
    <url>%2FBlog%2F2018%2F09%2F27%2Ftransition%2F</url>
    <content type="text"><![CDATA[参考链接： css.doyoe.com css2.1中文版 MDN transition 概述CSS transitions 提供了一种在更改CSS属性时控制动画速度的方法。 其可以让属性变化成为一个持续一段时间的过程，而不是立即生效的。比如，将一个元素的颜色从白色改为黑色，通常这个改变是立即生效的，使用 CSS transitions 后该元素的颜色将逐渐从白色变为黑色，按照一定的曲线速率变化。这个过程可以自定义。通常将两个状态之间的过渡称为隐式过渡（implicit transitions），因为开始与结束之间的状态由浏览器决定。 CSS transitions 可以决定哪些属性发生动画效果 (明确地列出这些属性)， 何时开始 (设置 delay）， 持续多久 (设置 duration) 以及如何动画 (定义timing funtion，比如匀速地或先快后慢)。 12345678910默认值:- transition-delay: 0s- transition-duration: 0s- transition-property: all- transition-timing-function: ease适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 看每个独立属性媒体： 交互 参考：可动画属性列表 语法transition是一个简写属性，用于transition-property, transition-duration, transition-timing-function, 和 transition-delay。 1234567891011121314151617181920212223/* Apply to 1 property *//* property name | duration */transition: margin-right 4s;/* property name | duration | delay */transition: margin-right 4s 1s;/* property name | duration | timing function */transition: margin-right 4s ease-in-out;/* property name | duration | timing function | delay */transition: margin-right 4s ease-in-out 1s;/* Apply to 2 properties */transition: margin-right 4s, color 1s;/* Apply to all changed properties */transition: all 0.5s ease-out;/* Global values */transition: inherit;transition: initial;transition: unset; 注意：在transition属性中，各个值的书写顺序是很重要的：第一个可以解析为时间的值会被赋值给transition-duration，第二个可以解析为时间的值会被赋值给transition-delay。 transition-property概述transition-property 指定应用过渡属性的名称 123456默认值： all适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 视觉 语法123456789101112131415161718/* Keyword values */transition-property: none;transition-property: all;/* &lt;custom-ident&gt; values */transition-property: test_05;transition-property: -specific;transition-property: sliding-vertically;/* Multiple values */transition-property: test1, animation4;transition-property: all, height, all;transition-property: all, -moz-specific, sliding;/* Global values */transition-property: inherit;transition-property: initial;transition-property: unset; none：没有过渡动画。 all：所有可被动画的属性都表现出过渡动画。 IDENT：属性名称。由小写字母 a 到 z，数字 0 到 9，下划线（_）和破折号（-）。第一个非破折号字符不能是数字。同时，不能以两个破折号开头。参考：可动画属性列表 transition-duration概述transition-duration 属性以秒或毫秒为单位指定过渡动画所需的时间。默认值为 0s ，表示不出现过渡动画。 可以指定多个时长，每个时长会被应用到由 transition-property 指定的对应属性上。如果指定的时长个数小于属性个数，那么时长列表会重复。如果时长列表更长，那么该列表会被裁减。两种情况下，属性列表都保持不变。 123456默认值： 0s适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 交互 语法12345678910/* &lt;time&gt; 值 */transition-duration: 6s;transition-duration: 120ms;transition-duration: 1s, 15s;transition-duration: 10s, 30s, 230ms;/* 全局值 */transition-duration: inherit;transition-duration: initial;transition-duration: unset; &lt;time&gt;&lt;time类型&gt;。表示过渡属性从旧的值转变到新的值所需要的时间。如果时长是 0s ，表示不会呈现过渡动画，属性会瞬间完成转变。不接受负值。 transition-timing-function概述CSS属性受到 transition effect的影响，会产生不断变化的中间值，而 CSS transition-timing-function 属性用来描述这个中间值是怎样计算的。实质上，通过这个函数会建立一条加速度曲线，因此在整个transition变化过程中，变化速度可以不断改变。 123456默认值： ease适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 交互 语法12345678910111213transition-timing-function: easetransition-timing-function: ease-intransition-timing-function: ease-outtransition-timing-function: ease-in-outtransition-timing-function: lineartransition-timing-function: cubic-bezier(0.1, 0.7, 1.0, 0.1)transition-timing-function: step-starttransition-timing-function: step-endtransition-timing-function: steps(4, end)transition-timing-function: ease, step-start, cubic-bezier(0.1, 0.7, 1.0, 0.1)transition-timing-function: inherit 通过transition-property中定义被过渡属性，每个 的值代表与这个属性相对应的timing function. cubic-bezier(x1, y1, x2, y2): 特定的贝塞尔曲线类型，4个数值需在[0, 1]区间内 steps(number_of_steps, direction): 接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是start或end，指定每一步的值发生变化的时间点。第二个参数是可选的，默认值为end。 step-start：等同于 steps(1, start) step-end：等同于 steps(1, end) ease-in-out: 由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) ease-out：由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0) ease-in：由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0) ease: 平滑过渡。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0) linear: 线性过渡。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0) transition-delay概述 transition-delay属性规定了在过渡效果开始作用之前需要等待的时间。 值以秒（s）或毫秒（ms）为单位，表明动画过渡效果将在何时开始。取值为正时会延迟一段时间来响应过渡效果；取值为负时会导致过渡立即开始。 123456默认值： 0适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 交互 语法12345678/* &lt;time&gt;?值 */transition-delay: 3s;transition-delay: 2s, 4ms;/* 全局变量 */transition-delay: inherit;transition-delay: initial;transition-delay: unset; &lt;time&gt;表明动画效果属性生效之前需要等待的时间。 transition代码实例]]></content>
  </entry>
  <entry>
    <title><![CDATA[微信小程序]]></title>
    <url>%2FBlog%2F2018%2F09%2F19%2FwechartMiniProgram%2F</url>
    <content type="text"><![CDATA[项目结构 1234567891011121314151617- page- - index- - - index.js- - - index.json- - - index.wxml- - - index.wxss- - log- - - log.js- - - log.json- - - log.wxml- - - log.wxss- utils- - util.js- app.js- app.json- app.wxss- project.config.json 四类文档： .json：配置文件 .wxml：模板文件 .wxss：样式文件 .js： js文件 配置文件 全局配置 123456789101112131415161718192021222324252627282930313233&#123; &quot;pages&quot;: [ &quot;pages/index/index&quot;, &quot;pages/logs/index&quot; ], &quot;window&quot;: &#123; &quot;backgroundTextStyle&quot;: &quot;light&quot;, //下拉 loading 的样式，仅支持 dark / light &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, //导航栏背景颜色 &quot;navigationBarTitleText&quot;: &quot;Demo&quot;, //导航栏标题文字内容 &quot;navigationBarTextStyle&quot;: &quot;black&quot;, //导航栏标题颜色，仅支持 black / white &quot;enablePullDownRefresh&quot;: true, //是否全局开启下拉刷新 &quot;backgroundColor&quot;: &quot;#000&quot; //页面上拉触底事件触发时距页面底部距离，单位为px &#125;, &quot;tabBar&quot;: &#123; &quot;color&quot;:&quot;#00ff00&quot;, //字体颜色； &quot;selectedColor&quot;: &quot;#ff0000&quot;, //选中tab字体颜色； &quot;backgroundColor&quot;: &quot;yellow&quot;, //tab背景颜色； &quot;borderStyle&quot;: &quot;black&quot;, //tab边框，只能为black和white； &quot;position&quot;:&quot;bottom&quot;, //tabBar位置； &quot;list&quot;: [&#123; //只能配置最少2个、最多5个 tab &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;text&quot;: &quot;首页&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/logs/logs&quot;, &quot;text&quot;: &quot;日志&quot; &#125;] &#125;, &quot;networkTimeout&quot;: &#123; &quot;request&quot;: 10000, &quot;downloadFile&quot;: 10000 &#125;, &quot;debug&quot;: true&#125; 页面配置 123456789101112&#123; &quot;navigationBarBackgroundColor&quot;: &quot;#fff”, //导航栏背景颜色 &quot;navigationBarTitleText&quot;: &quot;WeChat”, //导航栏标题文字内容 &quot;navigationBarTextStyle&quot;:&quot;black”, //导航栏标题颜色，仅支持 black / white &quot;backgroundTextStyle&quot;:&quot;light”, //下拉 loading 的样式，仅支持 dark / light &quot;backgroundColor&quot;: &quot;#ffffff&quot;, //窗口的背景色 &quot;enablePullDownRefresh&quot;: false, //是否开启下拉刷新。 &quot;onReachBottomDistance”: 50, //页面上拉触底事件触发时距页面底部距离，单位为px //只在页面配置中有效，无法在 app.json 中设置 &quot;disableScroll&quot;: false, //设置为 true 则页面整体不能上下滚动；&#125; 逻辑层注册小程序 App(Object)：注册小程序，只能在app.js里面调用，且只能调用一次 1234567891011121314151617181920App(&#123; onLaunch: function(&#123; //小程序初始化完成时触发，全局只触发一次。 path, //打开小程序的路径 query, //打开小程序的query scene, //打开小程序的场景 referrerInfo:&#123; //当场景为由从另一个小程序或公众号或App打开时，返回此字段 appId, //部分场景支持 extraData, //数据 &#125;, &#125;) &#123;&#125;, onShow: function(options) &#123;&#125;, //小程序启动，或从后台进入前台显示时触发。options和onLaunch一样 onHide: function() &#123;&#125;, //小程序从前台进入后台时触发。 onError: function(msg) &#123;&#125;, onPageNotFound: function(&#123; //小程序初始化完成时触发，全局只触发一次。 path, //不存在页面的路径 query, //打开不存在页面的query isEntryPage: true, //是否本次启动的首个页面 &#125;) &#123;&#125;, globalData: &apos;I am global data’ //自定义数据，用this可以访问。&#125;) getApp()：获取App实例 12var appInstance = getApp()console.log(appInstance.globalData) // I am global data 注册页面 Page(Object) 1234567891011121314151617181920212223242526272829303132333435Page(&#123; data, //初始化数据 //以下为生命周期函数 onLoad: function(&#123; //页面加载时触发。一个页面只会调用一次。 query, &#125;) &#123;&#125;, onShow: function(options) &#123;&#125;, //页面显示/切入前台时触发 onReady: function() &#123;&#125;, //初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。 onHide: function(options) &#123;&#125;, //页面隐藏/切入后台时触发 onUnload: function(msg) &#123;&#125;, //页面卸载时触发 //以下为事件处理函数 onPullDownRefresh: function() &#123;&#125;, //监听用户下拉刷新事件。 【wx.startPullDownRefresh，wx.stopPullDownRefresh】 onReachBottom: function() &#123;&#125;, //监听用户上拉触底事件 onPageScroll: function(&#123; //页面卸载时触发 srollTop, //页面在垂直方向已经滚动的距离 &#125;) &#123;&#125;, onShareAppMessage: function(&#123; //监听用户点击页面内转发按钮（&lt;button&gt; 组件 open-type=&quot;share&quot;）或右上角菜单“转发”按钮的行为 from, //1, button; 2, menu target, // button||undefined webViewUrl, //页面中包含&lt;web-view&gt;组件时，返回当前&lt;web-view&gt;的url &#125;) &#123; return &#123; title, //转发标题 path, //转发路径 imageUrl, //转发封面图片 &#125; &#125;, onTabItemTap: function(&#123; //点击 tab 时触发，1.9.0版本以上 index, //被点击tabItem的序号，从0开始 pagePath, // 被点击tabItem的页面路径 text, //被点击tabItem的按钮文字 &#125;) &#123;&#125;, &#125;) Page.setData() Page.route 视图层数据绑定1&lt;view&gt; &#123;&#123;message&#125;&#125; &lt;/view&gt; 条件渲染 ： wx:if， wx:elif，wx:else12345&lt;view class=&apos;test-view test-view-if&apos;&gt; &lt;text wx:if=&quot;&#123;&#123;length &gt; 5&#125;&#125;&quot;&gt; 1 &lt;/text&gt; &lt;text wx:elif=&quot;&#123;&#123;length &gt; 2&#125;&#125;&quot;&gt; 2 &lt;/text&gt; &lt;text wx:else&gt; 3 &lt;/text&gt;&lt;/view&gt; 列表渲染123456789//默认下标： index， 当前项默认变量：item&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;&lt;/view&gt;//使用 wx:for-item 可以指定数组当前元素的变量名，使用 wx:for-index 可以指定数组当前下标的变量名&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt; &#123;&#123;idx&#125;&#125;: &#123;&#123;itemName.message&#125;&#125;&lt;/view&gt; 模板12345678&lt;template name=&quot;msgItem&quot;&gt; &lt;view&gt; &lt;text&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125; &lt;/text&gt; &lt;text&gt; Time: &#123;&#123;time&#125;&#125; &lt;/text&gt; &lt;/view&gt;&lt;/template&gt;&lt;template is=&quot;msgItem&quot; data=&quot;&#123;&#123;...item&#125;&#125;&quot;/&gt; 事件123&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; bindtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt;&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat” bind:tap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt; bind：不阻止冒泡 catch： 阻止冒泡 引用import：可以使用引用文件定义的template &lt;import src=&quot;a.wxml&quot;/&gt; include：类似于将引用文件的全部代码拷贝到引用位置123&lt;include src=&quot;header.wxml&quot;/&gt; &lt;view&gt; body &lt;/view&gt;&lt;include src=&quot;footer.wxml&quot;/&gt; 样式： WXSS对css的两点扩充： 尺寸单位rpx 样式导入： @import &quot;common.wxss&quot;; 支持以下选择器： 选择器 样例 样例描述 .class .intro 选择所有拥有 class=”intro” 的组件 #id #firstname 选择拥有 id=”firstname” 的组件 element view 选择所有 view 组件 element, element view, checkbox 选择所有文档的 view 组件和所有的 checkbox 组件 ::after view::after 在 view 组件后边插入内容 ::before view::before 在 view 组件前面边插入内容 wxs wxs标签 属性名 类型 说明 module String 当前 标签的模块名。必填字段。 src String 引用 .wxs 文件的相对路径。仅当本标签为单闭合标签或标签的内容为空时有效。 .wxs 文件 wxml 通过wxs标签获取； wxs文件通过require 获取 自定义组件组件规则 类似于页面，一个自定义组件由 json wxml wxss js 4个文件组成 json 文件中进行自定义组件声明： component: true 使用Component() 注册组件 使用组件12345&#123; &quot;usingComponents&quot;: &#123; &quot;component-tag-name&quot;: &quot;path/to/the/custom/component&quot; &#125;&#125; slot 向组件传递数据 组件事件： triggerEvent()]]></content>
  </entry>
  <entry>
    <title><![CDATA[css属性:内容与媒体查询]]></title>
    <url>%2FBlog%2F2018%2F09%2F12%2Fmedia%2F</url>
    <content type="text"><![CDATA[内容content 用来和:after及:before伪元素一起使用，在对象前或后显示内容。 counter-increment 设定当一个selector发生时计数器增加的值。取值：id number counter-reset 将指定selector的计数器复位。取值：id number12345678910111213normal：默认值。表现与none值相同none：不生成任何值。&lt;attr&gt;：插入标签属性值&lt;url&gt;：使用指定的绝对或相对地址插入一个外部资源（图像，声频，视频或浏览器支持的其他任何资源）&lt;string&gt;：插入字符串counter(name)：使用已命名的计数器counter(name,list-style-type)：使用已命名的计数器并遵从指定的list-style-type属性counters(name,string)：使用所有已命名的计数器counters(name,string,list-style-type)：使用所有已命名的计数器并遵从指定的list-style-type属性no-close-quote：并不插入quotes属性的后标记。但增加其嵌套级别no-open-quote：并不插入quotes属性的前标记。但减少其嵌套级别close-quote：插入quotes属性的后标记open-quote：插入quotes属性的前标记 quotes设置或检索对象内使用的嵌套标记。取值 none | [ ] 媒体查询 通过不同的媒体类型和条件定义样式表规则。 媒体查询让CSS可以更精确作用于不同的媒体类型和同一媒体的不同条件。 媒体查询的大部分媒体特性都接受min和max用于表达“大于或等于”和“小与或等于”。如：width会有min-width和max-width 媒体查询可以被用在CSS中的@media和@import规则上，也可以被用在HTML和XML中。 12345eg:@media screen and (width:800px)&#123; … &#125;@import url(example.css) screen and (width:800px);&lt;link media=&quot;screen and (width:800px)&quot; rel=&quot;stylesheet&quot; href=&quot;example.css&quot; /&gt;&lt;?xml-stylesheet media=&quot;screen and (width:800px)&quot; rel=&quot;stylesheet&quot; href=&quot;example.css&quot; ?&gt; media12345678语法：@media mediatype and|not|only (media feature) &#123; CSS-Code;&#125;针对多个媒体类型的CSS规则，可以用逗号来隔开@media handheld and (min-width:360px),screen and (min-width:480px)&#123;body&#123;font-size:large;&#125;&#125; mediatype12345678910111213媒体类型mediatype 取值有 all：用于所有设备print：用于打印机和打印预览screen: 用于电脑屏幕，平板电脑，智能手机等speech: 应用于屏幕阅读器等发声设备media 4 废弃：braille 盲文embossed 盲文打印handheld 手持设备projection 项目演示，比如幻灯speech 演讲tty 固定字母间距的网格的媒体，比如电传打字机tv 电视 媒体特性width | height 定义输出设备中的页面可见区域宽度/高度 （接受min/max） aspect-ratio 定义输出设备中的页面可见区域宽度与高度的比率 （接受min/max） orientation（判断显示屏横向纵向） 定义输出设备中的页面可见区域高度是否大于或等于宽度 landscape: 设备横向 portrait: 设备纵向 resolution 定义设备的分辨率 eg:96dpi, 300dpi, 118dpcm （接受min/max） scan 定义电视类设备的扫描工序 progressive: 连续扫描 interlace: 交织扫描 grid 用来查询输出设备是否使用栅格或点阵 1代表是，0代表否 color | color-index | monochrome 定义输出设备每一组彩色原件的个数 | 定义在输出设备的彩色查询表中的条目数 | 定义在一个单色框架缓冲区中每像素包含的单色原件个数 （接受min/max） 如果不是彩色设备，则值等于0 media 4废弃，针对移动设备 device-width | device-height | device-aspect-ratio 定义输出设备的屏幕可见宽度宽度/高度 | 输出设备的屏幕可见宽度与高度的比率 （接受min/max） Media Queries Level 4简洁语法123456789简洁语法：@media (height &gt; 600px) &#123; body &#123; line-height: 1.4; &#125;&#125;@media (400px &lt;= width &lt;= 700px) &#123; body &#123; line-height: 1.4; &#125;&#125; update 输出设备修改内容外观的频率 none 渲染后，无法再更新布局。如：打印在纸上的文档。 slow 布局可以根据CSS的通常规则动态地改变，但是输出设备不能足够快地渲染或显示变化以使它们被感知为平滑动画。示例：电子书阅读器或严重不足的设备。 fast 布局可以根据CSS的通常规则动态地改变，并且输出设备的速度不受异常限制，因此可以使用诸如CSS动画之类的定期更新。比如：计算机屏幕。 overflow-block 输出设备如何处理沿块轴溢出视口的内容？ none 不显示溢出块轴的内容。 scroll 通过滚动可以看到溢出块轴的内容。 optional-paged 可以通过滚动查看溢出块轴的内容，但可以手动触发分页符（例如via break-inside等），以使以下内容显示在下一页上。 paged 内容被分解为不连续的页面; 在块轴中溢出一页的内容显示在下一页上。 overflow-inline 可以滚动沿着内联轴溢出视口的内容吗？ none 不显示溢出块轴的内容。 scroll 通过滚动到内容轴可以看到溢出内联轴的内容。]]></content>
  </entry>
  <entry>
    <title><![CDATA[css属性:Selectors选择符]]></title>
    <url>%2FBlog%2F2018%2F09%2F05%2Fselectors%2F</url>
    <content type="text"><![CDATA[元素选择符通配选择符 *选定所有的对象,出于性能考虑通常不建议使用因为会命中文档中所有的元素 123* &#123; rule&#125; 类型选择符以文档语言对象类型作为选择符 123div &#123; rule&#125; ID 选择符以唯一标识符 id 属性作为选择符 123#id &#123; rule&#125; 类选择符以 class 属性为选择符，不通与 ID 属性，class 属性可以定义多个 123.cls &#123; rule&#125; 关系选择符包含选择符(E F)123E F &#123; rule&#125; 选择所有被 E 元素包含的 F 元素。包含选择符将会命中所有符合条件的后代，包括儿子，孙子，孙子的孙子… 子选择符(E &gt; F)123E &gt; F &#123; rule&#125; 选择所有作为 E 元素的子元素 F。与 包含选择符(E F) 不同的是，子选择符只能命中子元素，而不能命中孙辈。 相邻选择符(E + F)选择紧贴在 E 元素之后 F 元素，元素 E 与 F 必须同属一个父级。 See the Pen 相邻选择符 by scliuyang (@scliuyang) on CodePen. 兄弟选择符(E ~ F)选择 E 元素后面的所有兄弟元素 F，元素 E 与 F 必须同属一个父级。 12345678910&lt;style&gt; /* 相邻选择符(E+F) */ h3 + p &#123; color: #f00; &#125; /* 兄弟选择符(E~F) */ h3 ~ p &#123; color: #f00; &#125;&lt;/style&gt;&lt;h3&gt;这是一个标题&lt;/h3&gt;&lt;p&gt;p1&lt;/p&gt;&lt;p&gt;p2&lt;/p&gt;&lt;p&gt;p3&lt;/p&gt; 这个例子中，如果是相邻选择符，那么只有 p1 会变成红色；如果是兄弟选择符，那么 p1/p2/p3 都会变成红色； 属性选择符E[att]选择具有 att 属性的 E 元素。 12345678&lt;style&gt;img[alt] &#123; margin: 10px;&#125;&lt;/style&gt;&lt;img src="图片url" alt="" /&gt;&lt;img src="图片url" /&gt; 此例，将会命中第一张图片，因为匹配到了 alt 属性 E[att=”val”]选择具有 att 属性且属性值等于 val 的 E 元素。 12345678&lt;style&gt;input[type="text"] &#123; border: 2px solid #000;&#125;&lt;/style&gt;&lt;input type="text" /&gt;&lt;input type="submit" /&gt; 此例，将会命中第一张 input，因为匹配到了 type 属性，并且属性值为 text E[att~=”val”]选择具有 att 属性且属性值为一用空格分隔的字词列表，其中一个等于 val 的 E 元素（包含只有一个值且该值等于 val 的情况）。 123456789&lt;style&gt;div[class~="a"] &#123; border: 2px solid #000;&#125;&lt;/style&gt;&lt;div class="a"&gt;1&lt;/div&gt;&lt;div class="b"&gt;2&lt;/div&gt;&lt;div class="a b"&gt;3&lt;/div&gt; 此例，将会命中 1, 3 两个 div，因为匹配到了 class 属性，且属性值中有一个值为 a E[att^=”val”]选择具有 att 属性且属性值为以 val 开头的字符串的 E 元素。 123456789&lt;style&gt;div[class^="a"] &#123; border: 2px solid #000;&#125;&lt;/style&gt;&lt;div class="abc"&gt;1&lt;/div&gt;&lt;div class="acb"&gt;2&lt;/div&gt;&lt;div class="bac"&gt;3&lt;/div&gt; 此例，将会命中 1, 2 两个 div，因为匹配到了 class 属性，且属性值以 a 开头 E[att$=”val”]选择具有 att 属性且属性值为以 val 结尾的字符串的 E 元素。 123456789&lt;style&gt;div[class$="c"] &#123; border: 2px solid #000;&#125;&lt;/style&gt;&lt;div class="abc"&gt;1&lt;/div&gt;&lt;div class="acb"&gt;2&lt;/div&gt;&lt;div class="bac"&gt;3&lt;/div&gt; 此例，将会命中 1, 3 两个 div，因为匹配到了 class 属性，且属性值以 c 结尾 E[att*=”val”]选择具有 att 属性且属性值为包含 val 的字符串的 E 元素。 123456789&lt;style&gt;div[class*="b"] &#123; border: 2px solid #000;&#125;&lt;/style&gt;&lt;div class="abc"&gt;1&lt;/div&gt;&lt;div class="acb"&gt;2&lt;/div&gt;&lt;div class="bac"&gt;3&lt;/div&gt; 此例，将会命中所有 div，因为匹配到了 class 属性，且属性值中都包含了 b E[att|=”val”]如果元素 E 拥有 att 属性，并且值为 val，或者值是以 val-开头的，那么 E 将会被选择。 12345678910&lt;style&gt;div[class|="a"] &#123; border: 2px solid #000;&#125;&lt;/style&gt;&lt;div class="a"&gt;0&lt;/div&gt;&lt;div class="a-test"&gt;1&lt;/div&gt;&lt;div class="b-test"&gt;2&lt;/div&gt;&lt;div class="c-test"&gt;3&lt;/div&gt; 在这个例子中，前 2 个 div 将会被命中： 第 1 个 div，拥有 class 属性，并且值为 a，所以被命中； 第 2 个 div，拥有 class 属性，值是 a 开头并紧跟着连接符“-”，所以被命中； 伪类选择符E:link,visited,hover,active如果需要给超链接定义：访问前，鼠标悬停，当前被点击，已访问这4种伪类效果，而又没有按照一致的书写顺序，不同的浏览器可能会有不同的表现 1234a:link &#123;&#125;a:visited &#123;&#125;a:hover &#123;&#125;a:active &#123;&#125; 可靠的顺序是：l(link)ov(visited)e h(hover)a(active)te, 即用喜欢(love)和讨厌(hate)两个词来概括 See the Pen love,hate by scliuyang (@scliuyang) on CodePen. E:focus设置对象在成为输入焦点（该对象的onfocus事件发生）时的样式。 E:lang语言类选择符 123456789101112&lt;style&gt;p:lang(zh-cmn-Hans) &#123; color: #f00;&#125;p:lang(en) &#123; color: #090;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p lang="zh-cmn-Hans"&gt;大段测试文字&lt;/p&gt;&lt;p lang="en"&gt;english&lt;/p&gt; E:not匹配不含有s选择符的元素E,语法E:not(s)，括号内可以填写所有的选择符 有个列表，每个列表项都有一条底边线，但是最后一项不需要底边线123.demo li:not(:last-child) &#123; border-bottom: 1px solid #ddd;&#125; :root匹配E元素在文档的根元素,在HTML中，根元素永远是HTML 1234:root &#123; --main-color: hotpink; --pane-padding: 5px 42px;&#125; 声明全局css变量 E:first-child匹配父元素的第一个子元素E。要使该属性生效，E元素必须是某个元素的子元素，E的父元素最高是body，即E可以是body的子元素 See the Pen E:first-child by scliuyang (@scliuyang) on CodePen. E:last-child匹配父元素的最后一个子元素E，和first-child类似 E:only-child匹配父元素仅有的一个子元素E,和first-child类似。即父元素的子元素有且仅有一个E E:nth-child(n)匹配父元素的第n个子元素E，假设该子元素不是E，则选择符无效。 奇偶匹配1234567891011121314&lt;style&gt;li:nth-child(2n)&#123;color:#f00;&#125; /* 偶数 */li:nth-child(2n+1)&#123;color:#000;&#125; /* 奇数 */li:nth-child(even)&#123;color:#f00;&#125; /* 偶数 */li:nth-child(odd)&#123;color:#000;&#125; /* 奇数 */&lt;/style&gt;&lt;ul&gt; &lt;li&gt;列表项一&lt;/li&gt; &lt;li&gt;列表项二&lt;/li&gt; &lt;li&gt;列表项三&lt;/li&gt; &lt;li&gt;列表项四&lt;/li&gt;&lt;/ul&gt; See the Pen nth-child by scliuyang (@scliuyang) on CodePen. E:nth-last-child(n)匹配父元素的倒数第n个子元素E，假设该子元素不是E，则选择符无效。 E:first-of-type See the Pen E:first-of-type by scliuyang (@scliuyang) on CodePen. E:last-of-type匹配父元素下的所有E子元素中的倒数第一个。 E:only-of-type和only-child差不多，不过父元素可以有多个子元素，但其中的子元素E必须是唯一的，不能出现多个。 E:nth-of-type(n)匹配父元素的第n个子元素E。匹配的是父元素的第n个为E的子元素（被命中的不一定是第n个子元素，因为匹配的不是第n个子元素，而是第n个为E的子元素） E:nth-last-of-type(n)匹配父元素的倒数第n个子元素E。 E:empty匹配没有任何子元素（包括text节点）的元素E。 See the Pen E:empty by scliuyang (@scliuyang) on CodePen. E:checked匹配用户界面上处于选中状态的元素E。(用于input type为radio与checkbox时) E:enabled匹配用户界面上处于可用状态的元素E。 See the Pen E:enabled by scliuyang (@scliuyang) on CodePen. E:disabled匹配用户界面上处于禁用状态的元素E。 E:targetURL后面跟锚点#，指向文档内某个具体的元素。这个被链接的元素就是目标元素(target element)，:target选择器用于选取当前活动的目标元素。 See the Pen E:target by scliuyang (@scliuyang) on CodePen. 伪对象选择符E::first-letter设置对象内的第一个字符的样式。此伪对象仅作用于块对象。内联对象要使用该伪对象，必须先将其设置为块级对象。 See the Pen E::first-letter by scliuyang (@scliuyang) on CodePen. E:first-line设置对象内的第一行的样式。 E::before，E::after设置在对象前（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用，并且必须定义content属性这个属性常用来实现一些ui特效或者动画效果，可以减少dom元素的数量。 E::placeholder设置对象文字占位符的样式。注意加上浏览器前缀 E::selection设置对象被选择时的样式。 需要注意的是，::selection只能定义被选择时的background-color，color及text-shadow See the Pen E::selection by scliuyang (@scliuyang) on CodePen. 选择器优先级 编号 权重 选择器或样式 1 1000 内联样式 2 100 ID选择器：#id{…} 3 10 类选择器，伪类选择器，属性选择器：.class{…}、:hover{…}、[arrtibute=value] 4 1 标签选择器，伪元素选择器：div{…}、::after{…} 5 0 其他选择器：通配选择器(*)，子选择器(&gt;)，相邻同胞选择器(+) 6 无穷大 important See the Pen selectorPriority by liuzhaozhao828 (@liuzhaozhao) on CodePen.]]></content>
  </entry>
  <entry>
    <title><![CDATA[修饰器（装饰器，注解）]]></title>
    <url>%2FBlog%2F2018%2F08%2F30%2FDecorator%2F</url>
    <content type="text"><![CDATA[修饰器（装饰器，注解）1.类的修饰12345678910@testableclass MyTestableClass &#123; // ...&#125;function testable(target) &#123; target.isTestable = true;&#125;MyTestableClass.isTestable // true 上面代码中，@testable就是一个修饰器。它修改了MyTestableClass这个类的行为，为它加上了静态属性isTestable。testable函数的参数target是MyTestableClass类本身。 1234567也就是说，修饰器是一个对类进行处理的函数。修饰器函数的第一个参数，就是所要修饰的目标类。function testable(target) &#123; // ...&#125;testable函数的参数target，就是会被修饰的类。 如果觉得一个参数不够用，可以在修饰器外面再封装一层函数。 12345678910111213function testable(isTestable) &#123; return function(target) &#123; target.isTestable = isTestable; &#125;&#125;@testable(true)class MyTestableClass &#123;&#125;MyTestableClass.isTestable // true@testable(false)class MyClass &#123;&#125;MyClass.isTestable // false react-redux @connect 装饰器实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。12class MyReactComponent extends React.Component &#123;&#125;export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent); 有了装饰器，就可以改写上面的代码。 12@connect(mapStateToProps, mapDispatchToProps)export default class MyReactComponent extends React.Component &#123;&#125; 相对来说，后一种写法看上去更容易理解。 2.方法的修饰修饰器不仅可以修饰类，还可以修饰类的属性。 12345class Person &#123; @readonly name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125;修饰器readonly用来修饰“类”的name方法。 修饰器函数readonly一共可以接受三个参数。 123456789101112131415function readonly(target, name, descriptor)&#123; // descriptor对象原来的值如下 // &#123; // value: specifiedFunction, // enumerable: false, // configurable: true, // writable: true // &#125;; descriptor.writable = false; return descriptor;&#125;readonly(Person.prototype, &apos;name&apos;, descriptor);// 类似于Object.defineProperty(Person.prototype, &apos;name&apos;, descriptor); 修饰器第一个参数是类的原型对象，上例是Person.prototype，修饰器的本意是要“修饰”类的实例，但是这个时候实例还没生成，所以只能去修饰原型（这不同于类的修饰，那种情况时target参数指的是类本身）；第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象。 例1：修改属性描述对象的enumerable属性，使得该属性不可遍历。 123456789class Person &#123; @nonenumerable get kidCount() &#123; return this.children.length; &#125;&#125;function nonenumerable(target, name, descriptor) &#123; descriptor.enumerable = false; return descriptor;&#125; 例2：下面的@log修饰器，可以起到输出日志的作用。 12345678910111213141516171819202122class Math &#123; @log add(a, b) &#123; return a + b; &#125;&#125;function log(target, name, descriptor) &#123; var oldValue = descriptor.value; descriptor.value = function() &#123; console.log(`Calling $&#123;name&#125; with`, arguments); return oldValue.apply(this, arguments); &#125;; return descriptor;&#125;const math = new Math();// passed parameters should get logged nowmath.add(2, 4); 上面代码中，@log修饰器的作用就是在执行原始的操作之前，执行一次console.log，从而达到输出日志的目的。 另外，修饰器有==注释==的作用。 123456@testableclass Person &#123; @readonly @nonenumerable name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125; 从上面代码中，我们一眼就能看出，Person类是可测试的，而name方法是只读和不可枚举的。 常见的修饰器库core-decorators.js（1）@autobindautobind修饰器使得方法中的this对象，绑定原始对象。 1234567891011121314import &#123; autobind &#125; from &apos;core-decorators&apos;;class Person &#123; @autobind getPerson() &#123; return this; &#125;&#125;let person = new Person();let getPerson = person.getPerson;getPerson() === person;// true （2）@readonly12345678910import &#123; readonly &#125; from &apos;core-decorators&apos;;class Meal &#123; @readonly entree = &apos;steak&apos;;&#125;var dinner = new Meal();dinner.entree = &apos;salmon&apos;;// Cannot assign to read only property &apos;entree&apos; of [object Object] （3）@overrideoverride修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。 （4）@deprecate (别名@deprecated)deprecate或deprecated修饰器在控制台显示一条警告，表示该方法将废除。 1234567891011121314151617181920212223242526import &#123; deprecate &#125; from &apos;core-decorators&apos;;class Person &#123; @deprecate facepalm() &#123;&#125; @deprecate(&apos;We stopped facepalming&apos;) facepalmHard() &#123;&#125; @deprecate(&apos;We stopped facepalming&apos;, &#123; url: &apos;http://knowyourmeme.com/memes/facepalm&apos; &#125;) facepalmHarder() &#123;&#125;&#125;let person = new Person();person.facepalm();// DEPRECATION Person#facepalm: This function will be removed in future versions.person.facepalmHard();// DEPRECATION Person#facepalmHard: We stopped facepalmingperson.facepalmHarder();// DEPRECATION Person#facepalmHarder: We stopped facepalming//// See http://knowyourmeme.com/memes/facepalm for more details.// Postal.js我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件。 1234567891011121314151617181920const postal = require(&quot;postal/lib/postal.lodash&quot;);export default function publish(topic, channel) &#123; const channelName = channel || &apos;/&apos;; const msgChannel = postal.channel(channelName); msgChannel.subscribe(topic, v =&gt; &#123; console.log(&apos;频道: &apos;, channelName); console.log(&apos;事件: &apos;, topic); console.log(&apos;数据: &apos;, v); &#125;); return function(target, name, descriptor) &#123; const fn = descriptor.value; descriptor.value = function() &#123; let value = fn.apply(this, arguments); msgChannel.publish(topic, value); &#125;; &#125;;&#125; 上面代码定义了一个名为publish的修饰器，它通过改写descriptor.value，使得原方法被调用时，会自动发出一个事件。 123456789101112131415161718// index.jsimport publish from &apos;./publish&apos;;class FooComponent &#123; @publish(&apos;foo.some.message&apos;, &apos;component&apos;) someMethod() &#123; return &#123; my: &apos;data&apos; &#125;; &#125; @publish(&apos;foo.some.other&apos;) anotherMethod() &#123; // ... &#125;&#125;let foo = new FooComponent();foo.someMethod();foo.anotherMethod(); Mixin在修饰器的基础上，可以实现Mixin模式。所谓Mixin模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法 12345678910const Foo = &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;class MyClass &#123;&#125;Object.assign(MyClass.prototype, Foo);let obj = new MyClass();obj.foo() // &apos;foo&apos; 上面代码之中，对象Foo有一个foo方法，通过Object.assign方法，可以将foo方法“混入”MyClass类，导致MyClass的实例obj对象都具有foo方法。这就是“混入”模式的一个简单实现。 我们部署一个通用脚本mixins.js，将 Mixin 写成一个修饰器。12345export function mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list); &#125;;&#125; 然后，就可以使用上面这个修饰器，为类“混入”各种方法。 1234567891011import &#123; mixins &#125; from &apos;./mixins&apos;;const Foo = &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;@mixins(Foo)class MyClass &#123;&#125;let obj = new MyClass();obj.foo() // &quot;foo&quot; 通过mixins这个修饰器，实现了在MyClass类上面“混入”Foo对象的foo方法。 TraitTrait 也是一种修饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。 以traits-decorator这个第三方模块作为例子。这个模块提供的traits修饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。 12345678910111213141516import &#123; traits &#125; from &apos;traits-decorator&apos;;class TFoo &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;const TBar = &#123; bar() &#123; console.log(&apos;bar&apos;) &#125;&#125;;@traits(TFoo, TBar)class MyClass &#123; &#125;let obj = new MyClass();obj.foo() // fooobj.bar() // bar 上面代码中，通过traits修饰器，在MyClass类上面“混入”了TFoo类的foo方法和TBar对象的bar方法。 Trait 不允许“混入”同名方法。一种解决方法是排除TBar的foo方法。 1234567891011121314151617import &#123; traits, excludes &#125; from &apos;traits-decorator&apos;;class TFoo &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;const TBar = &#123; bar() &#123; console.log(&apos;bar&apos;) &#125;, foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;@traits(TFoo, TBar::excludes(&apos;foo&apos;))class MyClass &#123; &#125;let obj = new MyClass();obj.foo() // fooobj.bar() // bar 另一种方法是为TBar的foo方法起一个别名。123456789101112131415161718import &#123; traits, alias &#125; from &apos;traits-decorator&apos;;class TFoo &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;const TBar = &#123; bar() &#123; console.log(&apos;bar&apos;) &#125;, foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;@traits(TFoo, TBar::alias(&#123;foo: &apos;aliasFoo&apos;&#125;))class MyClass &#123; &#125;let obj = new MyClass();obj.foo() // fooobj.aliasFoo() // fooobj.bar() // bar alias和excludes方法，可以结合起来使用。 12345@traits(TExample::excludes(&apos;foo&apos;,&apos;bar&apos;)::alias(&#123;baz:&apos;exampleBaz&apos;&#125;))class MyClass &#123;&#125;或者@traits(TExample::as(&#123;excludes:[&apos;foo&apos;, &apos;bar&apos;], alias: &#123;baz: &apos;exampleBaz&apos;&#125;&#125;))class MyClass &#123;&#125; 安装方式12345$ npm install babel-core babel-plugin-transform-decorators然后，设置配置文件.babelrc&#123; &quot;plugins&quot;: [&quot;transform-decorators&quot;]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[React 生命周期]]></title>
    <url>%2FBlog%2F2018%2F08%2F30%2FReact%20Life%20cycle%2F</url>
    <content type="text"><![CDATA[React 生命周期公式抽象 UI=render(data) 用户看到片的界面（UI），应该是一个纯函数（render）的执行结果,只接受数据（data）作为参数。 存函数的输出完全依赖于输入的函数，两次函数条用如果输入相同，得到的结果也绝对相同。 prop prop为property的简写，意为属性 prop是组件的对外接口，state是组件的内部状态，对外用prop，内部用state。 一个React组件通过定义自己能够接受的prop就定义了自己的对外公共接口。 每个React组件都是独自存在的模块，组件之外的一切都是外部世界，外部世界就是通过prop来和组件对话。 1&lt;SampleButton id=&quot;sample&quot; borderWidth=&#123;2&#125; onClick=&#123;onButtonClick&#125; style=&#123;&#123;color:&quot;red&quot;&#125;&#125; /&gt; HTML组件的属性都是字符串类型，而React组件的prop能支持任何一种js语言数据类型，比如数字，函数，对象。 当prop的类型不是字符串类型的时候在JSX中必须用花括号{}把prop值包住。 父组件可以通过prop给子组件传递数据，同样子组件也可以通过prop给父组件反馈数据，因为prop不限制存数据，也可以是函数，函数类型的prop等于让父组件交给了子组件一个回调函数，子组件调用此prop的时候，可以带上必要的参数，这样就可以反馈数据给父组件。 123456constructor(props) &#123; super(props); this.state = &#123; count: props.initValue || 0 &#125;&#125; propTypes 、defaultProps ( prop-types v16.0, babel-react-optimize 线上环境) 12345678910111213// propTypesimport PropTypes from &apos;prop-types&apos;;、SampleButton.propTypes = &#123; id: PropTypes.string.isRequired, borderWidth: PropTypes.number&#125;SampleButton.defaultProps=&#123; borderWidth: 0&#125;例子 prop和state的对比 prop用于定义外部接口，state用于记录内部状态； prop的赋值再外部世界实用组件时，state的赋值再组件内部； 组件不应该改变prop的值，而state存在的目的就是让组件来改变的； 组件的生命周期装载过程当组件第一次被渲染的时候，一次调用这些函数。 constructor组件自己的构造函数，可用于初始化state，绑定this环境等 getInitialState &amp; getDefaultProps只有React.createClass创造的组件会有，用于初始化state和给props初始值 componentWillMount在调用render函数之前调用，这里的所有事情都可以提前到constructor中做 render一个React组件可以忽略其他所有函数都不实现，但是一定要实现render函数，因为所有React组件的父类React.Component类对其他生命周期函数都有默认实现。 render 函数并不做实际的渲染动作，它只是返回一个JSX描述的结果，最终由React 来操作渲染过程。componentDidMount在调用render函数之后调用，注意点： render函数调用完后，不会立刻调用componentDidMount，它的触发点在render已经引发了渲染，组件已经被装载到DOM数上后。 例子 不同于componentWillMount可以在服务器和浏览器端被调用，componentDidMount只能在浏览器端被调用。这点在同构的时候会用到，同时也提供给开发者一个很好的位置去做只有浏览器才做的逻辑，比如通过ALAX获取数据用来填充组件内容。 有时候React需要和其他UI库配合使用，比如jQuery,比如d3.js等，因为DOM已经存在，事件函数已设置好，所以可以在这一步进行调用。更新过程componentWillReceiveProps 只要是父组件的render函数被调用，不管传递的porps有没有改变，都会触发子组件的componentWillReceiveProps。 注意子组件内部的this.setState方法不会触发这个函数，因为这个函数是根据新的props（也就是参数nextProps）来计算是不是要更新state。 例子 shouldComponentUpdata（nextProps,nextState） 此函数决定了一个组件什么时候不需要渲染，shouldComponentUpdata返回一个布尔值，告诉React库这个组件在这次更新中是否要继续。 恰当的使用shouldComponentUpdata能够大大提高React组件的性能。 如果不写，会继承React.Component中的默认实现方式，也就是简单的返回true。 例子扩展：React.PureComponentReact.PureComponent通过浅的prop和状态比较来实现shouldComponentUpdate() 在将来，React会将shouldComponentUpdate()视为提示而不是严格的指令，并且返回false仍然可能导致组件的重新呈现。componentWillUpdaterendercomponentDidUpdate 如果组件的shouldComponentUpdata返回true，接下来就会依次调用这三个函数。 与装载不同的是，这一对函数的Did函数（componentDidUpdate）并不是只在浏览器端执行。 在React组件更新时，原有内容被重制，所以用到的UI库（比如jQuery）需要在componentDidUpdate后再次调用jQuery代码。 卸载过程componentWillUnmount当React组件需要从DOM树上删掉之前，对应的componentWillUnmount函数会被调用，移除多余的DOM元素，避免内存泄漏。 React v16.3新生命周期开启异步渲染新引入的两个生命周期函数 getDerivedStateFromProps，getSnapshotBeforeUpdate 以及在未来 v17.0 版本中即将被移除的三个生命周期函数 componentWillMount，componentWillReceiveProps，componentWillUpdate . 装载 constructor() static getDerivedStateFromProps() render() componentDidMount() 移除 componentWillMount()更新 static getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() 移除 componentWillUpdate() componentWillReceiveProps()getDerivedStateFromProps(nextProps, prevState)getDerivedStateFromProps在调用render方法之前调用，无论是在初始安装还是后续更新。它应该返回一个更新状态的对象，或者返回null以不更新任何状态。 getSnapshotBeforeUpdate(prevProps, prevState)getSnapshotBeforeUpdate()在最近呈现的输出被提交到例如DOM之前调用。它使您的组件可以在可能更改之前从DOM捕获一些信息（例如滚动位置）。此生命周期返回的任何值都将作为参数传递给componentDidUpdate()。12345678910111213141516171819202122232425262728293031323334可能出现在需要以特殊方式处理滚动位置的聊天线程等UI中。比如jtalkclass ScrollingList extends React.Component &#123; constructor(props) &#123; super(props); this.listRef = React.createRef(); &#125; getSnapshotBeforeUpdate(prevProps, prevState) &#123; // 我们是否在列表中添加新项目? // 捕获滚动位置，以便我们稍后调整滚动. if (prevProps.list.length &lt; this.props.list.length) &#123; const list = this.listRef.current; return list.scrollHeight - list.scrollTop; &#125; return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; // 如果snapshot有返回值，我们就是添加了新项目. // 调整滚动，以便这些新项目不会将旧项目推出视图. // (这里的snapshot是从getSnapshotBeforeUpdate中返回的值) if (snapshot !== null) &#123; const list = this.listRef.current; list.scrollTop = list.scrollHeight - snapshot; &#125; &#125; render() &#123; return ( &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents... */&#125;&lt;/div&gt; ); &#125;&#125; 在上面的例子中，重要的是读取scrollHeight属性，getSnapshotBeforeUpdate因为“渲染”阶段生命周期（如render）和“提交”阶段生命周期（如getSnapshotBeforeUpdate和componentDidUpdate）之间可能存在延迟。 错误处理componentDidCatch(error, info)错误边界是React组件，它们在其子组件树中的任何位置捕获JavaScript错误，记录这些错误，并显示回退UI而不是崩溃的组件树。错误边界在渲染期间，生命周期方法以及它们下面的整个树的构造函数中捕获错误。 123456789101112131415161718192021class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; componentDidCatch(error, info) &#123; // Display fallback UI this.setState(&#123; hasError: true &#125;); // You can also log the error to an error reporting service logErrorToMyService(error, info); &#125; render() &#123; if (this.state.hasError) &#123; // You can render any custom fallback UI return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[css属性:颜色(color)与字体(font)]]></title>
    <url>%2FBlog%2F2018%2F08%2F21%2FcolorFont%2F</url>
    <content type="text"><![CDATA[颜色 color检索或设置对象的文本颜色。无默认值默认值：由user agent决定 适用于：所有元素 继承性：有 动画性：是 计算值：指定值 取值: color：指定颜色 说明1.可以使用Color Name(颜色名称), HEX, RGB, RGBA, HSL, HSLA, transparent来指定color。 Color Name(颜色名称)：red,blue; HEX（十六进制）：#RRGGBB；#ff0000,#ffffff; RGB: RGB(R,G,B); rgb(255,0,0); RGBA:此色彩模式与RGB相同，只是在RGB模式上新增了Alpha透明度rgb(255,0,0,0.5)； HSL、HSLA:色调（0-360），饱和度（0%-100%），亮度（0-100%）； transparent：transparent是全透明黑色(black)的速记法，即一个类似rgba(0,0,0,0)这样的值。 See the Pen MqYgEv by vivizhou0596 (@vivizhou0596) on CodePen. 2.注意，用颜色名称指定color可能不被一些浏览器接受。 3.color属性值被间接用来提供一个中间值currentColor以供其他接受颜色值的属性使用。 See the Pen yxyBZp by vivizhou0596 (@vivizhou0596) on CodePen. 字体 fontfontfont 简写属性在一个声明中设置所有字体属性。 复合属性：[ [font-style||font-variant||font-weight||font-stretch]?font-size[ /line-height]?font-family] | caption | icon | menu | message-box | small-caption | status-bar 取值： font-style：指定文本字体样式 font-variant：指定文本是否为小型的大写字母 font-weight：指定文本字体的粗细 font-stretch：指定文本字体拉伸变形 font-size：指定文本字体尺寸 line-height：指定文本字体的行高 font-family：指定文本使用某个字体或字体序列 caption：使用有标题的系统控件的文本字体（如按钮，菜单等）（CSS2） icon：使用图标标签的字体（CSS2） menu：使用菜单的字体（CSS2） message-box：使用信息对话框的文本字体（CSS2） small-caption：使用小控件的字体（CSS2） status-bar：使用窗口状态栏的字体（CSS2） 注：使用font属性参数必须按照如上的排列顺序，且font-size和font-family是不可忽略的。每个参数仅允许有一个值。忽略的将使用其参数对应的独立属性的默认值。 See the Pen GXgRym by vivizhou0596 (@vivizhou0596) on CodePen. font-style 定义字体的风格 normal：指定文本字体样式为正常的字体 italic：指定文本字体样式为斜体。对于没有设计斜体的特殊字体，如果要使用斜体外观将应用oblique oblique：指定文本字体样式为倾斜的字体。人为的使文字倾斜，而不是去选取字体中的斜体字 font-variant把段落设置为小型大写字母字体 normal：正常的字体 small-caps：小型的大写字母字体 font-weight设置文本的粗细 normal：正常的字体。相当于数字值400 bold：粗体。相当于数字值700。 bolder：定义比继承值更重的值 lighter：定义比继承值更轻的值 ：用数字表示文本字体粗细。取值范围：100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 font-size可设置字体的尺寸 absolute-size：根据对象字号进行调节。以 medium 作为基础参照，xx-small相当于medium 3/5 (h6)，x-small: 3/4，small: 8/9 (h5)，medium: 1 (h4)，large: 6/5 (h3)，x-large: 3/2 (h2)，xx-large: 2/1 (h1)， relative-size：相对于父对像中字号进行相对调节。使用成比例的em单位计算。 length：用长度值指定文字大小。不允许负值。 percentage：用百分比指定文字大小。其百分比取值是基于父对象中字体的尺寸。不允许负值。 font-family规定元素的字体系列 family-name：字体名称。按优先顺序排列。以逗号隔开。如果字体名称包含空格或中文，则应使用引号括起 generic-family：字体序列名称。font-family 可以把多个字体名称作为一个“回退”系统来保存。如果浏览器不支持第一个字体，则会尝试下一个。也就是说，font-family 属性的值是用于某个元素的字体族名称或/及类族名称的一个优先表。浏览器会使用它可识别的第一个值。 有两种类型的字体系列名称： 字体名称：具体字体的名称，比如：”times”、”courier”、”arial”,”宋体”。 通常字体系列名称：比如：”serif”（笔画两端有脚）、”sans-serif”（笔画两端没有脚）、”cursive”、”fantasy”、”monospace”（所有字符宽度都一样） 提示： 1.使用逗号分割每个值，并始终提供一个类族名称作为最后的选择。 2.所有的表单元素都是无法继承body的字体属性的，所以平常的只在body后加入字体是不行的，需要为用的表单元素单独设计字体 多列通过 CSS3，您能够创建多个列来对文本进行布局 - 就像报纸那样！ 常用属性： 1.column-count 属性规定元素应该被分隔的列数；2.column-gap 属性规定列之间的间隔；3.column-rule 属性设置列之间的宽度、样式和颜色规则。 See the Pen GXggeP by vivizhou0596 (@vivizhou0596) on CodePen.]]></content>
  </entry>
  <entry>
    <title><![CDATA[css属性:文本(Text)]]></title>
    <url>%2FBlog%2F2018%2F08%2F16%2Ftext%2F</url>
    <content type="text"><![CDATA[参考链接： css.doyoe.com css2.1中文版 MDN 一.text-transformtext-transform 属性指定如何将元素的文本进行大小写变形。它可以用于使文本显示为全大写或全小写，也可单独对每一个单词进行操作。 1234567初始值 none适用元素 all elements. It also applies to ::first-letter and ::first-line.是否是继承属性 yes适用媒体 visual计算值 as specifiedAnimation type discrete正规顺序 the unique non-ambiguous order defined by the formal grammar 语法1234567891011/* Keyword values */text-transform: capitalize;text-transform: uppercase;text-transform: lowercase;text-transform: none;text-transform: full-width;/* Global values */text-transform: inherit;text-transform: initial;text-transform: unset; capitalize: 将文本中的每个单词以大写字母开头(只会对每个单词第一个字母做变形，对其他字母保持不变) uppercase: 将文本中的所有字符变为大写 lowercase： 将文本中的所有字符变为小写 none： 默认值，不对文本进行大小写转换 full-width： 将所有字符转换成fullwidth形式。如果字符没有相应的fullwidth形式，将保留原样。这个值通常用于排版拉丁字符和数字等表意符号。(全角) text-transform代码演示 二、white-spacewhite-space 属性是用来设置如何处理元素中的空白。 1234567初始值 normal适用元素 all elements是否是继承属性 yes适用媒体 visual计算值 as specifiedAnimation type discrete正规顺序 the unique non-ambiguous order defined by the formal grammar 语法 1234567white-space: normalwhite-space: nowrapwhite-space: prewhite-space: pre-wrapwhite-space: pre-linewhite-space: inherit normal 默认值,连续的空白符会被合并，换行符会被当作空白符来处理。填充line盒子时，必要的话会换行。 nowrap 和 normal 一样，连续的空白符会被合并。但文本内的换行无效。 pre 连续的空白符会被保留。在遇到换行符或者元素时才会换行。 pre-wrap 连续的空白符会被保留。在遇到换行符或者元素，或者需要为了填充line盒子时才会换行。 pre-line 连续的空白符会被合并。在遇到换行符或者元素，或者需要为了填充line盒子时会换行。 — 换行符 空格和制表符 文字转行 normal 合并 合并 转行 nowrap 合并 合并 不转行 pre 保留 保留 不转行 pre-wrap 保留 保留 转行 pre-line 保留 合并 转行 white-space代码示例 三、tab-sizetab-size 定义元素内容中制表符的长度。(a tab (U+0009) character),只有当white-space的属性值为：pre | pre-wrap时，该属性的定义才有效 1234567初始值 8适用元素 block containers是否是继承属性 yes适用媒体 visual计算值 the specified integer or an absolute lengthAnimation type a length正规顺序 the unique non-ambiguous order defined by the formal grammar 123456789101112/* &lt;integer&gt; values */tab-size: 4;tab-size: 0;/* &lt;length&gt; values */tab-size: 10px;tab-size: 2em;/* Global values */tab-size: inherit;tab-size: initial;tab-size: unset; tab-size代码示例 四、word-breakword-break定义元素内容文本的字间与字符间的换行行为 1234567初始值 normal适用元素 all elements是否是继承属性 yes适用媒体 visual计算值 as specifiedAnimation type discrete正规顺序 the unique non-ambiguous order defined by the formal grammar 12345678word-break: normal word-break: break-all word-break: keep-all/* Global values */word-break: inherit;word-break: initial;word-break: unset; normal使用默认的断行规则。 break-all对于non-CJK (CJK 指中文/日文/韩文) 文本，可在任意字符间断行。 keep-allCJK 文本不断行。 Non-CJK 文本表现同 normal。 break-word与break-all相同，不同的地方在于它要求一个没有断行破发点的词必须保持为一个整体单位。这与word-wrap的break-word值效果相同 word-break代码示例 五、word-wrap/overflow-wrap 注：word-wrap 属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap 。 word-wrap 现在被当作 overflow-wrap 的 “别名”。 稳定的谷歌 Chrome 和 Opera 浏览器版本支持这种新语法。 1234567初始值 normal适用元素 all elements是否是继承属性 yes适用媒体 visual计算值 as specifiedAnimation type discrete正规顺序 the unique non-ambiguous order defined by the formal grammar 12345678/* Keyword values */overflow-wrap: normal;overflow-wrap: break-word;/* Global values */overflow-wrap: inherit;overflow-wrap: initial;overflow-wrap: unset; normal表示在正常的单词结束处换行。 break-word表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被被分割的单词会被强制分割换行。 word-wrap/overflow-wrap代码示例 六、text-aligntext-align CSS属性定义行内内容（例如文字）如何相对它的块父元素对齐。text-align 并不控制块元素自己的对齐，只控制它的行内内容的对齐。 1234567初始值 start, or a nameless value that acts as left if direction is ltr, right if direction is rtl if start is not supported by the browser.适用元素 block containers是否是继承属性 yes适用媒体 visual计算值 as specified, except for the match-parent value which is calculated against its parent&apos;s direction value and results in a computed value of either left or rightAnimation type discrete正规顺序 order of appearance in the formal grammar of the values 语法12345678910111213141516171819202122/* Keyword values */text-align: left;text-align: right;text-align: center;text-align: justify;text-align: justify-all;text-align: start;text-align: end;text-align: match-parent;/* Character-based alignment in a table column */text-align: &quot;.&quot;;text-align: &quot;.&quot; center;/* Block alignment values (Non-standard syntax) */text-align: -moz-center;text-align: -webkit-center;/* Global values */text-align: inherit;text-align: initial;text-align: unset; start如果内容方向是左至右，则等于left，反之则为right。 end如果内容方向是左至右，则等于right，反之则为left。 left行内内容向左侧边对齐。 right行内内容向右侧边对齐。 center行内内容居中。 &lt;string&gt;第一个出现的该（单字符）字符串被用来对齐。跟随的关键字定义对齐的方向。例如，可用于让数字值根据小数点对齐。 justify文字向两侧对齐，对最后一行无效。 justify-all和justify一致，但是强制使最后一行两端对齐。 match-parent和inherit类似，区别在于start和end的值根据父元素的direction确定，并被替换为恰当的left或right。 text-align示例 七、text-align-lasttext-align-last 描述的是一段文本中最后一行在被强制换行之前的对齐规则。 注意：IE浏览器下，如果text-align-last要生效，必须先定义text-align为justify； 1234567初始值 auto适用元素 block containers是否是继承属性 yes适用媒体 visual计算值 as specifiedAnimation type discrete正规顺序 the unique non-ambiguous order defined by the formal grammar 12345678910111213/* Keyword values */text-align-last: auto;text-align-last: start;text-align-last: end;text-align-last: left;text-align-last: right;text-align-last: center;text-align-last: justify;/* Global values */text-align-last: inherit;text-align-last: initial;text-align-last: unset; auto每一行的对齐规则由 text-align 的值来确定，当 text-align 的值是 justify，text-align-last 的表现和设置了 start 的表现是一样的，即如果文本的展示方向是从左到右，则最后一行左侧对齐与内容盒子。经测试，当 text-align 的值为 right，并且 text-align-last 设置为 auto 时，文本最后一行的对齐方式相当于 text-align-last 被设置为 right 时的效果。即 text-align-last 设置为 auto 后的表现跟 text-align 的设置有关。 start与 direction 的设置有关。如果文本展示方向是从左到右，起点在左侧，则是左对齐；如果文本展示方向是从右到左，起点在右侧，则是右对齐。如果没有设置 direction ，则按照浏览器文本的默认显示方向来确定。 end与 direction 的设置有关。如果文本展示方向是从左到右，末尾在右侧，则是右对齐；如果文本展示方向是从右到左，末尾在左侧，则是左对齐。如果没有设置 direction ，则按照浏览器文本的默认显示方向来确定。 left最后一行文字与内容盒子的左侧对齐 right最后一行文字与内容盒子的右侧对齐 center最后一行文字与内容盒子居中对齐 justify最后一行文字的开头语内容盒子的左侧对齐，末尾与右侧对齐。 text-align-last示例 八、text-justifytext-justify定义的是当文本的 text-align 属性被设置为 :justify 时的齐行方法。 1234567初始值 auto适用元素 inline-level and table-cell elements是否是继承属性 yes适用媒体 visual计算值 as specifiedAnimation type discrete正规顺序 the unique non-ambiguous order defined by the formal grammar auto：允许浏览器用户代理确定使用的两端对齐法则。 none：禁止两端对齐。 inter-word：通过增加字之间的空格对齐文本。该行为是对齐所有文本行最快的方法，它的两端对齐行为对段落的最后一行无效。 inter-ideograph：为表意字文本提供完全两端对齐，增加或减少表意字和词间的空格。 inter-cluster：调整文本无词间空格的行。这种模式的调整是用于优化亚洲语言文档的 distribute：通过增加或减少字或字母之间的空格对齐文本，适用于东亚文档，尤其是泰国。 kashida：通过拉长选定点的字符调整文本。这种调整模式是特别为阿拉伯脚本语言提供的。需要IE5.5+支持 inter-character通过在文本中的字符之间添加空间来实现行对齐（这将会改变 letter-spacing 的值），比如日语就是最适合使用这个属性的语言。 text-justify示例 九、word-spacingword-spacing属性用于声明标签和单词直接的间距行为。 12345678初始值 normal适用元素 all elements. It also applies to ::first-letter and ::first-line.是否是继承属性 yesPercentages refer to the width of the affected glyph适用媒体 visual计算值 an optimum, minimum, and maximum value, each consisting of either an absolute length, a percentage, or the keyword normalAnimation type a length正规顺序 the unique non-ambiguous order defined by the formal grammar 123456789101112131415/* Keyword value */word-spacing: normal;/* &lt;length&gt; values */word-spacing: 3px;word-spacing: 0.3em;/* &lt;percentage&gt; values */word-spacing: 50%;word-spacing: 200%;/* Global values */word-spacing: inherit;word-spacing: initial;word-spacing: unset; normal初始值，正常的单词间距，由当前字体和/或浏览器定义。 &lt;length&gt;通过指定具体的额外间距来增加字体的单词间距。 &lt;percentage&gt;通过指定受影响字符的宽度的百分比的方式来增加的间距。 word-spacing示例 十、letter-spacingletter-spacing属性明确了文字字母的间距行为。 1234567初始值 normal适用元素 all elements. It also applies to ::first-letter and ::first-line.是否是继承属性 yes适用媒体 visual计算值 an optimum value consisting of either an absolute length or the keyword normalAnimation type a length正规顺序 the unique non-ambiguous order defined by the formal grammar 1234567letter-spacing: normal;letter-spacing: 0.3em;letter-spacing: 3px;letter-spacing: .3px;letter-spacing: inherit; normal(默认值) 此间距是按照当前字体的正常间距确定的。 用户代理根据此属性来确定文字的默认对齐方式。等同于间距 0。 &lt;length&gt;指定文字间的间距以替代默认间距。可以是负值，但有可能会出现 implementation 限制。用户代理不会在此基础上进一步增加或缩减间距来对齐文字。 letter-spacing示例 合理使用：一个很大的正或负的letter-spacing值会将应用这个样式的单词边为不可读的。给文本letter-spacing属性应用了一个很大的正值，字母之间的距离会很远，以至于文本中的单词将显示为一系列单独的，无有任何关联的字母。给文本letter-spacing属性应用了一个很大的负值，字母将会互相重叠到一个点，在这个点上单词可能无法识别了。 一个最佳的易辨认的字母间距（letter-spacing）必须根据具体情况来确定，因为不同的字体系列具有不同的字符宽度。没有任何一个值可以确保所有字体系列自动保持它们的可读性。 十一、text-indenttext-indent 属性 规定了 一个元素 首行 文本内容之前应该有多少水平空格。水平空格是块级包含元素的内容盒子的左边(对于从右向左布局来说是右边). 12345678初始值 0适用元素 block containers是否是继承属性 yesPercentages refer to the width of the containing block适用媒体 visual计算值 the percentage as specified or the absolute length, plus any keywords as specifiedAnimation type a length, percentage or calc();正规顺序 The length or percentage before the keywords, if both are present. If several keywords are present, they appear in the same order as their appearance in the formal grammar. 1234567891011121314151617/* &lt;length&gt; values */text-indent: 3mm;text-indent: 40px;/* &lt;percentage&gt; value relative to the containing block width */text-indent: 15%;/* Keyword values */text-indent: 5em each-line;text-indent: 5em hanging;text-indent: 5em hanging each-line;/* Global values */text-indent: inherit;text-indent: initial;text-indent: unset; &lt;length&gt;使用固定的值来指定文本的缩进。允许使用负值。 &lt;percentage&gt;使用包含块宽度的百分比作为缩进。 each-line（css3）文本缩进会影响第一行，以及使用强制断行后的第一行。 hanging（css3）该值会对所有的行进行反转缩进：除了第一行之外的所有的行都会被缩进，看起来就像第一行设置了一个负的缩进值。 注：each-line和hanging均为实验性功能 chrome开启: chrome://flags/#enable-experimental-web-platform-features text-indent代码示例 十二、vertical-alignvertical-align属性用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。 12345678初始值 baseline适用元素 inline-level and table-cell elements. It also applies to ::first-letter and ::first-line.是否是继承属性 否Percentages refer to the line-height of the element itself适用媒体 visual计算值 for percentage and length values, the absolute length, otherwise the keyword as specifiedAnimation type a length正规顺序 the unique non-ambiguous order defined by the formal grammar 123456789101112131415161718192021/* keyword values */vertical-align: baseline;vertical-align: sub;vertical-align: super;vertical-align: text-top;vertical-align: text-bottom;vertical-align: middle;vertical-align: top;vertical-align: bottom;/* &lt;length&gt; values */vertical-align: 10em;vertical-align: 4px;/* &lt;percentage&gt; values */vertical-align: 20%;/* Global values */vertical-align: inherit;vertical-align: initial;vertical-align: unset; 取值 (对于行内(inline)元素)下列值只对父级行内元素或者一个父级块容器元素的strut有效 在下面的定义中，对于行内非替换元素，用于对齐的盒是那个高度为’line-height’（包括该盒的字形和两边的半行距，见上文）的盒。对于其它所有元素，用于对齐的盒都是外边距框（margin box） baseline默认。把盒的基线与父级盒的基线对齐。如果该盒没有基线，就把下外边距边界和父级的基线对齐。 sub把该盒的基线降低到合适的位置作为父级盒的下标（该值不影响该元素文本的字体大小） super把该盒的基线提升到合适的位置作为父级盒的上标（该值不影响该元素文本的字体大小） text-top把该盒的顶端和父级的内容区（content area）的顶端对齐 text-bottom把该盒的底端和父级的内容区的底端对齐 middle把该盒的垂直中点与父级盒的基线加上父级的半x-height对齐 &lt;length&gt;把该盒提升（正值）或者降低（负值）这个距离。值’0cm’表示与“基线”相同 &lt;percentage&gt;把该盒提升（正值）或者降低（负值）这个距离（’line-height’值的百分比）。值’0%’表示与“基线”相同 以下两个值是相对于整行来说的： top元素及其后代的顶端与line-box正行的顶端对齐。 bottom元素及其后代的底端与line-box整行的底端对齐。 如果元素没有基线baseline，则以它的外边距的下边缘为基线。 取值 (对于table-cell元素) baseline (and sub, super, text-top, text-bottom, &lt;length&gt;, and &lt;percentage&gt;)与同行单元格的基线对齐。 top单元格的内边距的上边缘与行的顶端对齐。 middle单元格垂直居中。 bottom单元格的内边距的下边缘与行的底端对齐。 可以取负值。 vertical-align代码示例 十四、line-heightline-height 属性用于设置多行元素的空间量，比如文本。对于块级元素，它指定元素行盒（line boxes）的最小高度。对于非替代的inline元素，它用于计算行盒（line box）的高度。 1234567Value: normal | &lt;number&gt; | &lt;length&gt; | &lt;percentage&gt; | inherit初始值: normal适用元素: 所有元素是否可继承: yesPercentages: 参考元素自身的字体大小Media: visualComputed value: 对于&lt;length&gt;和&lt;percentage&gt;是绝对的值，否则与指定值相同 1234567891011121314151617/* Keyword value */line-height: normal;/* Unitless values: use this number multipliedby the element&apos;s font size */line-height: 3.5;/* &lt;length&gt; values */line-height: 3em;/* &lt;percentage&gt; values */line-height: 34%;/* Global values */line-height: inherit;line-height: initial;line-height: unset; normal告诉用户代理根据该元素的字体把应用值设置为一个“合理的”值。该值与的含义相同。我们推荐介于1.0到1.2的“常规”应用值。计算值为’normal’ &lt;length&gt;指定的长度用来计算行框的高度。负值是非法的 &lt;number&gt;该属性的应用值为这个数字乘以该元素的字体大小。负值是非法的。计算值与指定值相同 &lt;percentage&gt;该属性的计算值为这个百分比乘以该元素的字体大小的计算值。负值是非法的 line-height代码示例 十五、text-size-justifytext-size-adjust 属性 允许我们控制将文本溢出算法应用到一些手机设备上。这个属性还没有写进标准，使用时必须加上前缀：-moz-text-size-adjust，-webkit-text-size-adjust,，和 -ms-text-size-adjust。 许多网页还没有用手机开发，智能手机浏览器和桌面浏览器渲染网页时在一些地方有不同。他们不是以设备屏幕宽度布局网页，而是用比屏幕宽一些的视窗去布局网页，通常是800到1000像素。为了将视窗上的布局映射到原始设备屏幕上，手机浏览器要么只渲染整个页面的一部分，要么将视窗缩放至原始屏幕大小。 因为缩放适配小屏幕而导致文字会变得很小，许多手机浏览器会使用文本溢出算法让文本变大而更易读。当一个包含文本的元素宽度用了100%，他的文本大小会增加直到达到一个易读的大小，但是不会修改布局。 text-size-adjust 这个属性允许开发者去除或者修改这个浏览器默认行为，因为当网页设计已经处理小屏幕的宽度问题时不需要他。 这个属性并不是标准。 你必须为每个你想要应用的浏览器加上属性前缀。 不同浏览器，这个属性有不同的行为和语法。更多的信息，请查看下面的浏览器兼容性部分。 这个属性只有在一些智能手机和平板电脑上使用。 桌面浏览器和一些平板电脑浏览器并没有一些溢出算法。 如果 -webkit-text-size-adjust 显式设置为 none, 老的基于桌面的WebKit和平板电脑浏览器，像 Chrome≤26 或者 Safari≤5, 不会忽略这个属性, 反而会阻止用户在web界面放大或缩小。# 不是所有的浏览器都支持这个属性使用百分比值(例如 Webkit 和 Trident , 但是 Gecko不支持). 检查下面浏览器兼容的部分查看更多的信息。 12345678910111213/* 文本不会放大 */text-size-adjust: none;/* 文本可能会被放大 */text-size-adjust: auto;/* 文本固定为原大小的80% */text-size-adjust: 80%;/* 全局的值 */text-size-adjust: inherit;text-size-adjust: initial;text-size-adjust: unset; none禁用浏览器的文本溢出算法。在老的基于webkit内核的桌面端浏览器，这将阻止用户将网页放大或缩小。 auto启用 浏览器的文本溢出算法。该值用于取消先前使用CSS设置的none。 &lt;percentage&gt;启用 浏览器的文本溢出算法，具体用一个百分数来确定文本放大范围。 text-size-justify代码示例]]></content>
  </entry>
  <entry>
    <title><![CDATA[line-height 爱我你怕了吗]]></title>
    <url>%2FBlog%2F2018%2F08%2F09%2Fline-height%2F</url>
    <content type="text"><![CDATA[line-height 爱我你怕了吗 1. line-height的定义行高：两行文字基线（baseline）之间的距离 什么是基线 行高 行高可以让单行文本垂直居中？ 真的垂直居中了吗？ 2. line-height与行内框盒子模型 所有内联元素的样式表现都与行内框盒子模型有关 1&lt;p&gt;我是字&lt;em&gt;我是斜体字&lt;/em&gt;我是字我是我是字我是字我是字我是字我是字我是字我是字我是字&lt;/p&gt; 内容区域(content area),是一种围绕文字看不见的盒子。内容区域的大小与font-size有关 内联盒子(inline boxes)不会让内容显示成块，而是排成一行 ，如果外部含有标签属于内联盒子，如果仅仅是文本择属于匿名内联盒子 行框盒子(line boxes)，一行一个行框盒子，由内联盒子组成 包含盒子(containing boxes),由一行行的行框盒子组成 行内框盒子对line-height的现实意义 3.line-height 的各类属性值 normal 默认属性值，跟浏览器相关 且与字体类型有关 1.5 根据当前元素的font-size计算 1.5em 使用具体长度值作为行高值 150% 相对于设置了该行高属性元素的的的font-size大小计算 inherit 继承 4.line-height的高度机理 内容区域高度(content area)+行间距(vertical spacing) = 行高(line-height) 内容区域的高度只与字号和字体有关，与行高无关 内联元素的高度由内部的内容区域决定 inline-block 和块级元素的高度由内部内联元素的行高有关 一个inline-block元素，如果里面没有inline内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘，否则，其基线就是元素里面最后一行内联元素的基线。 宋体字体下内容区域的高度等于字体大小 更直观的例子 5. line-height 与 vertical-align 的关系123456789101112131415161718192021/* 关键字值 */vertical-align: baseline;vertical-align: sub;vertical-align: super;vertical-align: text-top;vertical-align: text-bottom;vertical-align: middle;vertical-align: top;vertical-align: bottom;/* &lt;长度&gt; 值 */vertical-align: 10em;vertical-align: 4px;/* &lt;百分比&gt; 值 */vertical-align: 10%;/* 全局值 */vertical-align: inherit;vertical-align: initial;vertical-align: unset; vertical-align的百分比值不是相对于字体大小或者其他什么属性计算的，而是相对于line-height计算的。举个简单的例子，如下CSS代码： 1234&#123; line-height: 30px; vertical-align: -10%;&#125; 等同于 1234&#123; line-height: 30px; vertical-align: -3px; /* = 30px * -10% */&#125; 真的垂直居中了吗？]]></content>
  </entry>
  <entry>
    <title><![CDATA[css属性:背景与边框]]></title>
    <url>%2FBlog%2F2018%2F08%2F02%2Fborder%2F</url>
    <content type="text"><![CDATA[边框border 定义元素边框的外观特性1border：&lt;line-width&gt; || &lt;line-style&gt; || &lt;color&gt; border-width 定义元素的边框厚度1border-width:top right bottom left border-style 定义元素的边框样式 12345678910//可用取值hidden：隐藏边框。dotted：点状轮廓。ashed：虚线轮廓。solid：实线轮廓double：双线轮廓。两条单线与其间隔的和等于指定的border-width值groove：3D凹槽轮廓。ridge：3D凸槽轮廓。inset：3D凹边轮廓。outset：3D凸边轮廓。 border-color 定义元素的边框颜色 border-shadow 定义元素的阴影 12345678//可用取值none：无阴影&lt;length&gt;①：第 1 个长度值定义元素的阴影水平偏移值。正值，阴影出现在元素右侧；负值，则阴影出现在元素左侧&lt;length&gt;②：第 2 个长度值定义元素的阴影垂直偏移值。正值，阴影出现在元素底部；负值，则阴影出现在元素顶部&lt;length&gt;③：第 3 个长度值定义元素的阴影模糊值半径（如果提供了）。该值越大阴影边缘越模糊，若该值为0，阴影边缘不出现模糊。不允许负值&lt;length&gt;④：第 4 个长度值定义元素的阴影外延值（如果提供了）。正值，阴影将向四面扩展；负值，则阴影向里收缩&lt;color&gt;：定义元素阴影的颜色。如果该值未定义，阴影颜色将默认取当前最近的文本颜色inset：定义元素的阴影类型为内阴影。该值为空时，则元素的阴影类型为外阴影 结合伪类实现阴影 border-radius 定义元素的阴影 12345border-radius：&lt;length&gt; | &lt;percentage&gt;border-radius = border-top-left-radius, border-top-right-radius, border-bottom-right-radius, border-bottom-left-radius border-image 定义将图像应用到元素的边框上 12345678910border-image-source：定义元素边框背景图像，可以是图片路径或使用渐变创建的“背景图像”。border-image-slice：定义元素边框背景图像从什么位置开始分割。border-image-width：定义元素边框背景图像厚度。border-image-outset：定义元素边框背景图像的外延尺寸。border-image-repeat：定义元素边框背景图像的平铺方式。 背景background 定义元素的背景特性 一个元素可以设置多组背景图像，每组属性间使用逗号分隔。（背景色background-color不能设置多组，背景色通常都定义在最后一组上） 如果设置的多组背景图之间存在着交集（即存在着重叠关系），前面的背景图会覆盖在后面的背景图之上。 background-color 定义元素使用的背景颜色 背景图像会覆盖在背景颜色。 1background-color:transparent； //设置背景色透明 background-image 定义元素使用的背景图像 1渐变属性：inear-gradient, radial-gradient, repeating-linear-gradient, repeating-radial-gradient linear-gradient123456789101112下述值用来表示渐变的方向，可以使用角度或者关键字来设置：&lt;angle&gt;：用角度值指定渐变的方向（或角度）。to left：设置渐变为从右到左。相当于: 270degto right：设置渐变从左到右。相当于: 90degto top：设置渐变从下到上。相当于: 0degto bottom：设置渐变从上到下。相当于: 180deg。这是默认值，等同于留空不写。&lt;color-stop&gt; 用于指定渐变的起止颜色：&lt;color&gt;：指定颜色。&lt;length&gt;：用长度值指定起止色位置。不允许负值&lt;percentage&gt;：用百分比指定起止色位置。background-image:linear-gradient(135deg, #9DC3E6 0%, #F4B183 25%, #C9C9C9 50%, #FFD966 75%, #A9D18E 100%); 渐变图标 http://lea.verou.me/css3patterns/ background-repeat 定义元素的背景图像如何填充。 123456repeat-x：背景图像在横向上平铺repeat-y：背景图像在纵向上平铺repeat：背景图像在横向和纵向平铺no-repeat：背景图像不平铺round：当背景图像不能以整数次平铺时，会根据情况缩放图像。（CSS3）space：当背景图像不能以整数次平铺时，会用空白间隙填充在图像周围。（CSS3） background-attachment 定义滚动时背景图像相对于谁固定 123fixed：背景图像相对于视口（viewport）固定。scroll：背景图像相对于元素固定，也就是说当元素内容滚动时背景图像不会跟着滚动，因为背景图像总是要跟着元素本身。但会随元素的祖先元素或窗体一起滚动。local：背景图像相对于元素内容固定，也就是说当元素随元素滚动时背景图像也会跟着滚动，因为背景图像总是要跟着内容。（CSS3） background-position 指定背景图像在元素中出现的位置 12345678910&lt;percentage&gt;：用百分比指定背景图像在元素中出现的位置。可以为负值。参考容器尺寸减去背景图尺寸进行换算。&lt;length&gt;：用长度值指定背景图像在元素中出现的位置。可以为负值。center：背景图像横向或纵向居中。left：背景图像从元素左边开始出现。right：背景图像从元素右边开始出现。top：背景图像从元素顶部开始出现。bottom：背景图像从元素底部开始出现。示例：假设要定义背景图像在容器中右下方，并且距离右边和底部各有20pxbackground: url(test1.jpg) no-repeat right 20px bottom 20px; 雪碧图 https://www.toptal.com/developers/css/sprite-generator .icon2{background-position: -40px -40;} background-origin 指定的背景图像计算background-position时的参考原点(位置) 123border-box从border区域（含border）开始显示背景图像。padding-box：从padding区域（含padding）开始显示背景图像。content-box：从content区域开始显示背景图像。 background-clip 指定对象的背景图像向外裁剪的区域 1234border-box：从border区域（含border）开始向外裁剪背景。padding-box：从padding区域（含padding）开始向外裁剪背景。content-box：从content区域开始向外裁剪背景。text：从前景内容的形状（比如文字）作为裁剪区域向外裁剪，如此即可实现使用背景作为填充色之类的遮罩效果。 文字遮罩 http://demo.doyoe.com/css3/background-clip/mask-text2.htmbackground-size 定义背景图像的尺寸大小 12345&lt;length&gt;：用长度值指定背景图像大小。不允许负值。&lt;percentage&gt;：用百分比指定背景图像大小。不允许负值。auto：背景图像的真实大小。cover：将背景图像等比缩放到完全覆盖容器，背景图像有可能超出容器。contain：将背景图像等比缩放到宽度或高度与容器的宽度或高度相等，背景图像始终被包含在容器内]]></content>
  </entry>
  <entry>
    <title><![CDATA[css属性:尺寸与补白]]></title>
    <url>%2FBlog%2F2018%2F08%2F01%2Fdimension%2F</url>
    <content type="text"><![CDATA[尺寸Dimension用于控制元素的高度和宽度，包含属性有width、height、min-width、max-height、max-width、max-height; 语法&lt;length&gt; | &lt;percentage&gt; | auto默认值为auto 适用于：除非置换内联元素，table-row, table-row-group之外的所有元素width height设置或检索对象的宽度和高度 对于img对象来说，仅指定一个尺寸属性，另一值将根据图片源尺寸等比例缩放；特殊的比如iframe, canvas，当width的计算值为auto时，则宽度的使用值为300px,height为auto时,高度的使用值为150px。 See the Pen 尺寸 by Fengguangnan (@fengguangnan) on CodePen. min-width min-height设置或检索对象的最小宽度和最小高度max-width max-height 设置或检索对象的最大宽度和最大高度 min-* 值小于width(height)时，min-*会被忽略、大于width(height)时，min-*属性将会被忽略，同时width(height)会忽略自己的值定义而使用min-*的值作为自己的使用值； max-* 值小于width(height)时，会被忽略，同时width(height)会忽略自己的值定义而使用max-*的值作为自己的使用值、值大于width(height)时，max-*属性将会被忽略； 如果min-*属性的值大于max-*属性的值，max-*将会自动以min-*的值作为自己的值。 See the Pen 尺寸 by Fengguangnan (@fengguangnan) on CodePen. 补白margin(外补白)指从自身边框到另一个容器边框之间的距离，就是容器外距离语法[ &lt;length&gt; | &lt;percentage&gt; | auto ]{1,4} 取值：auto：水平（默认）书写模式下，margin-top/margin-bottom计算值为0，margin-left/margin-right取决于可用空间 &lt;length&gt;： 用长度值来定义margin。==可以为负值== &lt;percentage&gt;：用百分比来定义外补白。水平（默认）书写模式下，参照其父元素的 width 进行计算，其它情况参照 height ，==可以为负值 == 如果提供全部四个参数值顺序顺序 margin:top、right、bottom、left; 适用于：所有元素，除非 table | inline-table | table-caption 的表格类元素之外 属性值也可以拆分成四个：margin-top、margin-right、margin-bottom、margin-leftmargin-top、margin-bottom:非置换内联元素要使用该属性必须转为块级或行内块级 See the Pen margin by Fengguangnan (@fengguangnan) on CodePen. padding(内补白)指自身边框到自身内部另一个容器边框之间的距离，就是容器内距离。 语法[ &lt;length&gt; | &lt;percentage&gt;]{1,4} 取值：&lt;length&gt;：用长度值来定义内补白。==不允许负值==&lt;percentage&gt;：用百分比来定义内补白。水平（默认）书写模式下，参照其包含块 width 进行计算，其它情况参照 height 。==不允许负值== 如果提供全部四个参数值顺序与margin相同:top、right、bottom、left; 适用于：所有元素，除 table-row-group | table-header-group | table-footer-group | table-column-group | table-row 外 属性值也可以拆分成四个：padding-top、padding-right、padding-bottom、padding-left 给行内元素定义纵向内补白（padding-top/padding-bottom）时，虽然不需要将之转化为行内块或者块级，但是给行内元素设置纵向内补白并不会影响布局。内补白会在当前元素的行框基础上向顶部和顶部外延， See the Pen padding by Fengguangnan (@fengguangnan) on CodePen.]]></content>
  </entry>
  <entry>
    <title><![CDATA[css属性:表格table]]></title>
    <url>%2FBlog%2F2018%2F08%2F01%2Ftable%2F</url>
    <content type="text"><![CDATA[table-layout: fixed : 固定布局 auto： 自动算法 See the Pen table-layout by liuzhaozhao828 (@liuzhaozhao) on CodePen. border-collapse: collapse: 相邻边框合并 separate: 边框独立 See the Pen border-collapse by liuzhaozhao828 (@liuzhaozhao) on CodePen. border-spacing: 只在boder-collapse为 separate的情况下有效果 复合属性，横向相邻和纵向相邻分开设置：border-spacing：10px 20px IE6/7无效，兼容方式&lt;table border=&quot;1&quot; cellspacing=&quot;20&quot;&gt; See the Pen border-spacing by liuzhaozhao828 (@liuzhaozhao) on CodePen. caption-side: caption的位置 取值 top bottom left right (只有Firefox支持) See the Pen caption-side by liuzhaozhao828 (@liuzhaozhao) on CodePen. empty-cells: 取值 hide show 单元格没值时，隐藏边框 只在boder-collapse为 separate的情况下有效果 See the Pen empty-cells by liuzhaozhao828 (@liuzhaozhao) on CodePen.]]></content>
  </entry>
  <entry>
    <title><![CDATA[css属性:布局layout]]></title>
    <url>%2FBlog%2F2018%2F07%2F31%2Flayout%2F</url>
    <content type="text"><![CDATA[display none： 1.不展示 2.不占物理空间（区别visibility：hidden) inline： 1.内联元素 2.Line-height:可以设置内联元素的高度 3.Margin: 内联非替换元素margin-top, margin-bottom无效 See the Pen display-1 by liuzhaozhao828 (@liuzhaozhao) on CodePen. 4.Padding: 父元素未指宽高，内联非替换不会撑高父元素，内联替换会撑高父元素 See the Pen display-2 by liuzhaozhao828 (@liuzhaozhao) on CodePen. block： 1.块元素 2.独占一行 inline-block： 1.内联块元素 2.内联块之间有缝隙 回车字符占用了4px，解决方法：父元素设置 font-size: 0 table系属性值 1.table：块元素级的表格，相当于标签&lt;table&gt; 2.inline-table：内联元素级的表格，相当于标签&lt;table&gt; 3.table-caption：表格标题，相当于标签&lt;caption&gt; 4.table-cell：表格单元格，相当于标签&lt;td&gt; 5.table-row：指定对象作为表格行，相当于标签&lt;tr&gt; 6.table-row-group：表格行组，相当于标签&lt;tbody&gt; 7.table-column：表格列，相当于标签&lt;col&gt; 8.table-column-group：表格列组显示，相当于标签&lt;colgroup&gt; 9.table-header-group：表格标题组，相当于标签&lt;thead&gt; 10.table-footer-group：表格脚注组，相当于标签&lt;tfoot&gt; 其他： 1.list-item：列表项目 2.run-in:根据上下文决定是内联还是块, chrome不支持 visibility 取值： visible hidden hidden隐藏元素，但是保留物理空间 clear 取值： both left right float 取值： none，left， right 特性： 1.脱离文档流 2.变为块元素 清除浮动的三种办法： 1.增加div元素，该元素通过clear属性清除浮动 2.增加伪元素:after，通过clear属性清除浮动 3.父元素增加属性overflow:hidden，生成BFC清除浮动 See the Pen float-clear by liuzhaozhao828 (@liuzhaozhao) on CodePen. overflow 取值：visible, hidden，scroll, auto overflow等同于 overflow-x overflow-y 值为非visibile时，将会为它的内容创建一个新的块格式化上下文（BFC）]]></content>
  </entry>
  <entry>
    <title><![CDATA[css属性:position]]></title>
    <url>%2FBlog%2F2018%2F07%2F25%2Fpositions%2F</url>
    <content type="text"><![CDATA[postion用于指定一个元素在文档中的定位方式 使用语法支持属性static | relative | absolute | fixed | sticky,其中默认值为static注意，position 属性只针对display不为table-column-group | table-column的元素生效 static默认值,left、top、bottom、right四个定位属性不会生效 relative对象遵循常规流，并且参照自身在常规流中的位置通过top，right，bottom，left这4个定位偏移属性进行偏移时不会影响常规流中的任何元素。 See the Pen position_relative by scliuyang (@scliuyang) on CodePen. absolute对象脱离常规流，此时偏移属性参照的是离自身最近的定位祖先元素，如果没有定位的祖先元素(或者说祖先元素都是position:static)，则一直回溯到window也就是整个窗口元素。盒子的偏移位置不影响常规流中的任何元素，其margin不与其他任何margin折叠(这里是由于创建了BFC，块级格式化上下文导致的，推荐阅读深入理解BFC和Margin Collapse)。他跟relative最大的区别就是脱离文档流，也就是说相邻元素会无视并占据它所在的位置 See the Pen position_absolute by scliuyang (@scliuyang) on CodePen. fixed与absolute一致，但偏移定位是以窗口为参考。当出现滚动条时，对象不会随着滚动。 sticky对象在常态时遵循常规流。它就像是relative和fixed的合体，当在屏幕中时按常规流排版，当卷动到屏幕外时则表现如fixed。该属性的表现是现实中你见到的吸附效果 See the Pen position_sticky by scliuyang (@scliuyang) on CodePen. 不过这属性兼容性不咋的 定位属性top/bottom支持属性auto | &lt;length&gt; | &lt;percentage&gt;,默认值为auto,仅在position非static时生效 auto：无特殊定位，根据HTML定位规则在文档流中分配 ：用长度值来定义距离顶部的偏移量。可以为负值。 ：用百分比来定义距离顶部的偏移量。百分比参照包含块的高度。可以为负值。 在relative时,auto计算值为0,如果top和bottom其中一个为auto，则auto相当于另一个的负值，即top = -bottom；如果top和bottom的值都不为auto，则忽略bottom。在absolute时,auto计算为元素的正常文档流位置,如果top和bottom都设值会设置元素的高度，相当于离包含块的顶部和底部多少距离 See the Pen absolute_top_bttom by scliuyang (@scliuyang) on CodePen. left/right和top/bottom基本一致，只是percentage计算参照的是包含块的宽度 demo水平垂直居中 See the Pen 水平垂直居中 by scliuyang (@scliuyang) on CodePen. clip(被废弃，clip-path取代) rect(|auto |auto |auto |auto)：依据上-右-下-左的顺序提供自对象左上角为(0,0)坐标计算的四个偏移数值，其中任一数值都可用auto替换，即此边不剪切。必须设置absolute或者fixed才会生效，没有clip-path好用 See the Pen clip by scliuyang (@scliuyang) on CodePen.]]></content>
  </entry>
  <entry>
    <title><![CDATA[css属性:列表list]]></title>
    <url>%2FBlog%2F2018%2F07%2F25%2Flist%2F</url>
    <content type="text"><![CDATA[列表 list给 li 或者 display:list-item 的元素设置样式 list-style复合属性list-style：&lt;&#39; list-style-type &#39;&gt; || &lt;&#39; list-style-position &#39;&gt; || &lt;&#39; list-style-image &#39;&gt; list-style-type设置列表样式,取值 disc：实心圆(CSS1) circle：空心圆(CSS1) square：实心方块(CSS1) decimal：阿拉伯数字(CSS1) lower-roman：小写罗马数字(CSS1) upper-roman：大写罗马数字(CSS1) lower-alpha：小写英文字母(CSS1) upper-alpha：大写英文字母(CSS1) none：不使用项目符号(CSS1) armenian：传统的亚美尼亚数字(CSS2) cjk-ideographic：浅白的表意数字(CSS2) georgian：传统的乔治数字(CSS2) lower-greek：基本的希腊小写字母(CSS2) hebrew：传统的希伯莱数字(CSS2) hiragana：日文平假名字符(CSS2) hiragana-iroha：日文平假名序号(CSS2) katakana：日文片假名字符(CSS2) katakana-iroha：日文片假名序号(CSS2) lower-latin：小写拉丁字母(CSS2) upper-latin：大写拉丁字母(CSS2) 仅当list-style-image属性为none或指定图像不可用时才生效 See the Pen list-type by scliuyang (@scliuyang) on CodePen. list-style-image设置样式为图片，取值 none:不指定图像，默认内容标记将被 &lt;’ list-style-type ‘&gt; 代替。 url:使用绝对或相对地址指定列表项标记图像。如果图像地址无效，默认内容标记将被 &lt;’ list-style-type ‘&gt; 代替。 See the Pen list-img by scliuyang (@scliuyang) on CodePen. list-style-position设置或检索作为对象的列表项标记如何根据文本排列。取值 outside: 列表项目标记放置在文本以外，且环绕文本不根据标记对齐 inside: 列表项目标记放置在文本以内，且环绕文本根据标记对齐 See the Pen list-position by scliuyang (@scliuyang) on CodePen.]]></content>
  </entry>
</search>
